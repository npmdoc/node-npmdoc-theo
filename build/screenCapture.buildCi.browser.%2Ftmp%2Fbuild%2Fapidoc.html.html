<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/salesforce-ux/theo">theo (v5.0.0)</a>
</h1>
<h4>A set of Gulp plugins for transforming and formatting Design Tokens</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo">module theo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.formatIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>formatIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getFormat">
            function <span class="apidocSignatureSpan">theo.</span>getFormat
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getTransform">
            function <span class="apidocSignatureSpan">theo.</span>getTransform
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getValueTransform">
            function <span class="apidocSignatureSpan">theo.</span>getValueTransform
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.kebabCase">
            function <span class="apidocSignatureSpan">theo.</span>kebabCase
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.file">
            function <span class="apidocSignatureSpan">theo.</span>plugins.file
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.format">
            function <span class="apidocSignatureSpan">theo.</span>plugins.format
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.getResult">
            function <span class="apidocSignatureSpan">theo.</span>plugins.getResult
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.transform">
            function <span class="apidocSignatureSpan">theo.</span>plugins.transform
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.prop_set">
            function <span class="apidocSignatureSpan">theo.</span>prop_set
            <span class="apidocSignatureSpan">(file, valueTransforms, options = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerFormat">
            function <span class="apidocSignatureSpan">theo.</span>registerFormat
            <span class="apidocSignatureSpan">(name, formatter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerTransform">
            function <span class="apidocSignatureSpan">theo.</span>registerTransform
            <span class="apidocSignatureSpan">(name, valueTransforms)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerValueTransform">
            function <span class="apidocSignatureSpan">theo.</span>registerValueTransform
            <span class="apidocSignatureSpan">(name, matcher, transformer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.transformIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>transformIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.valueTransformIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>valueTransformIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">theo.</span>plugins</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.formatIsRegistered">module theo.formatIsRegistered</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.formatIsRegistered.formatIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>formatIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.getFormat">module theo.getFormat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getFormat.getFormat">
            function <span class="apidocSignatureSpan">theo.</span>getFormat
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.getTransform">module theo.getTransform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getTransform.getTransform">
            function <span class="apidocSignatureSpan">theo.</span>getTransform
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.getValueTransform">module theo.getValueTransform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getValueTransform.getValueTransform">
            function <span class="apidocSignatureSpan">theo.</span>getValueTransform
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.kebabCase">module theo.kebabCase</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.kebabCase.kebabCase">
            function <span class="apidocSignatureSpan">theo.</span>kebabCase
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.plugins">module theo.plugins</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.file">
            function <span class="apidocSignatureSpan">theo.plugins.</span>file
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.format">
            function <span class="apidocSignatureSpan">theo.plugins.</span>format
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.getResult">
            function <span class="apidocSignatureSpan">theo.plugins.</span>getResult
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.transform">
            function <span class="apidocSignatureSpan">theo.plugins.</span>transform
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.plugins.file">module theo.plugins.file</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.file.file">
            function <span class="apidocSignatureSpan">theo.plugins.</span>file
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.plugins.format">module theo.plugins.format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.format.format">
            function <span class="apidocSignatureSpan">theo.plugins.</span>format
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.plugins.getResult">module theo.plugins.getResult</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.getResult.getResult">
            function <span class="apidocSignatureSpan">theo.plugins.</span>getResult
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.plugins.transform">module theo.plugins.transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.transform.transform">
            function <span class="apidocSignatureSpan">theo.plugins.</span>transform
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.prop_set">module theo.prop_set</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.prop_set.prop_set">
            function <span class="apidocSignatureSpan">theo.</span>prop_set
            <span class="apidocSignatureSpan">(file, valueTransforms, options = {})</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.registerFormat">module theo.registerFormat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerFormat.registerFormat">
            function <span class="apidocSignatureSpan">theo.</span>registerFormat
            <span class="apidocSignatureSpan">(name, formatter)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.registerTransform">module theo.registerTransform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerTransform.registerTransform">
            function <span class="apidocSignatureSpan">theo.</span>registerTransform
            <span class="apidocSignatureSpan">(name, valueTransforms)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.registerValueTransform">module theo.registerValueTransform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerValueTransform.registerValueTransform">
            function <span class="apidocSignatureSpan">theo.</span>registerValueTransform
            <span class="apidocSignatureSpan">(name, matcher, transformer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.transformIsRegistered">module theo.transformIsRegistered</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.transformIsRegistered.transformIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>transformIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.valueTransformIsRegistered">module theo.valueTransformIsRegistered</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.valueTransformIsRegistered.valueTransformIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>valueTransformIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo" id="apidoc.module.theo">module theo</a></h1>


    <h2>
        <a href="#apidoc.element.theo.formatIsRegistered" id="apidoc.element.theo.formatIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>formatIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&gt; typeof FORMATS[name] !== 'undefined'</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.getFormat" id="apidoc.element.theo.getFormat">
        function <span class="apidocSignatureSpan">theo.</span>getFormat
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFormat = function (name) {
  if (!this.formatIsRegistered(name)) {
    throw TheoError(`"${name}" is not a registered format`)
  }
  return FORMATS[name]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.getTransform" id="apidoc.element.theo.getTransform">
        function <span class="apidocSignatureSpan">theo.</span>getTransform
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTransform = function (name) {
  if (!this.transformIsRegistered(name)) {
    throw TheoError(`"${name}" is not a registered transform`)
  }
  return _.merge([], TRANSFORMS[name])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.getValueTransform" id="apidoc.element.theo.getValueTransform">
        function <span class="apidocSignatureSpan">theo.</span>getValueTransform
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValueTransform = function (name) {
  if (!this.valueTransformIsRegistered(name)) {
    throw TheoError(`"${name}" is not a registered valueTransform`)
  }
  return _.merge({}, VALUE_TRANSFORMS[name])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.kebabCase" id="apidoc.element.theo.kebabCase">
        function <span class="apidocSignatureSpan">theo.</span>kebabCase
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(string) =&gt; noCase(string, null, '-')</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.file" id="apidoc.element.theo.plugins.file">
        function <span class="apidocSignatureSpan">theo.</span>plugins.file
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(filePath) =&gt; {
  let stream = new through.obj()
  fs.readFile(filePath, (err, buffer) =&gt; {
    if (err) return stream.emit('error', err)
    let file = new gutil.File({
      path: filePath,
      contents: buffer
    })
    stream.write(file)
    stream.end()
  })
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;resources&gt;
  &lt;color name="colorBrand" type="color"&gt;#ffbada55&lt;/color&gt;
&lt;/resources&gt;
```

## API

#### `theo.<span class="apidocCodeKeywordSpan">plugins.file</span>(filePath)` &lt;a name="plugins.file"&gt;&lt;/
a&gt;

Push a new file into a transform stream and return the stream.
This is an alternative to using gulp.

**`@param {string} filePath`**
The name of the registered transform
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.format" id="apidoc.element.theo.plugins.format">
        function <span class="apidocSignatureSpan">theo.</span>plugins.format
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&gt; {
  let defaults = {
    propsFilter: () =&gt; true,
    propsMap: prop =&gt; prop
  }
  if (typeof options !== 'object') {
    throw TheoError('format() options must be an object')
  }
  options = _.merge({}, defaults, options)
  if (typeof options.propsFilter !== 'function') {
    throw TheoError('format() options.propsFilter must be a function')
  }
  if (typeof options.propsMap !== 'function') {
    throw TheoError('format() options.propsMap must be a function')
  }
  // Get the formatter
  if (typeof FORMATS[type] === 'undefined') {
    throw TheoError(`"${type}" is not a registerd format`)
  }
  let formatter = FORMATS[type]
  return through.obj((file, enc, next) =&gt; {
    let newFile = file.clone()
    // Get the transformed JSON
    let json = util.parsePropsFile(newFile)
    // Rename the file
    newFile.path = newFile.path.replace(/(json|yml)$/, type)
    // Run filter/map the props
    let updatedProps = _(json.props)
      .filter(options.propsFilter)
      .map(options.propsMap)
      .value()
    // Convert the props to a key/value
    json.props = _.reduce(updatedProps, (props, prop) =&gt; {
      props[prop.name] = prop
      return props
    }, {})
    json.propKeys = Object.keys(json.props)
    // Format the json
    let formatted = formatter(json, _.merge({}, options, {
      path: file.path
    }))
    // Set the file contents to the result of the formatter
    newFile.contents = Buffer.from(formatted, 'utf8')
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
const gulp = require('gulp')
const theo = require('theo')

gulp.src('design/props.json')
  .pipe(theo.plugins.transform('web'))
  .pipe(theo.<span class="apidocCodeKeywordSpan">plugins.format</span>('scss'))
  .pipe(gulp.dest('dist'))
```

## Design Tokens &lt;a name="overview"&gt;&lt;/a&gt;

Theo consumes **Design Token** files which are a central location to store
design related information such as colors, fonts, widths, animations, etc. These raw
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.getResult" id="apidoc.element.theo.plugins.getResult">
        function <span class="apidocSignatureSpan">theo.</span>plugins.getResult
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(callback) =&gt;
through.obj((file, enc, next) =&gt; {
  if (typeof callback === 'function' &amp;&amp; file.isBuffer()) {
    let result = file.contents.toString()
    callback(result)
    return next(null, file)
  }
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...
###### Styleguide

See &lt;https://salesforce-ux.github.io/design-properties&gt;.


***

#### `theo.<span class="apidocCodeKeywordSpan">plugins.getResult</span>([callback])`

Get the result of a transform/format

**`@param {function} [callback]`**
The function to call for each result in the stream

#### Example:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.transform" id="apidoc.element.theo.plugins.transform">
        function <span class="apidocSignatureSpan">theo.</span>plugins.transform
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&gt; {
  if (typeof options !== 'undefined' &amp;&amp; typeof options !== 'object') {
    throw TheoError('transform() options must be an object')
  }
  if (!_.has(TRANSFORMS, type)) {
    throw TheoError(`"${type}" is not a registered transform`)
  }
  let transform = TRANSFORMS[type].map(name =&gt; VALUE_TRANSFORMS[name])
  return through.obj((file, enc, next) =&gt; {
    let newFile = file.clone()
    try {
      newFile.contents = new PropSet(newFile, transform, options).transform().toBuffer()
    } catch (err) {
      return next(err)
    }
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Example

```js
const gulp = require('gulp')
const theo = require('theo')

gulp.src('design/props.json')
  .pipe(theo.<span class="apidocCodeKeywordSpan">plugins.transform</span>('web'))
  .pipe(theo.plugins.format('scss'))
  .pipe(gulp.dest('dist'))
```

## Design Tokens &lt;a name="overview"&gt;&lt;/a&gt;

Theo consumes **Design Token** files which are a central location to store
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.prop_set" id="apidoc.element.theo.prop_set">
        function <span class="apidocSignatureSpan">theo.</span>prop_set
        <span class="apidocSignatureSpan">(file, valueTransforms, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PropSet {

  constructor (file, valueTransforms, options = {}) {
    if (typeof file.isBuffer !== 'function' || typeof file.isBuffer === 'undefined') {
      throw TheoError('transform() must use vinyl files')
    }

    let defaults = {
      includeRawValue: false,
      includeMeta: false,
      resolveAliases: true
    }

    this.file = file
    this.path = file.path
    this.valueTransforms = valueTransforms
    this.options = Object.assign({}, defaults, options)

    this._init()
  }

  _init () {
    let { options } = this
    // Create the definition
    let def = {
      global: {},
      aliases: {}
    }
    // Merge the JSON into the definition
    try {
      let json = util.parsePropsFile(this.file)
      if (options.jsonPreProcess) {
        json = options.jsonPreProcess(json)
      }
      def = _.merge(def, json)
    } catch (e) {
      throw TheoError(`transform() encountered an invalid Design Token file: ${this.file.path}`)
    }
    // Raw
    if (options.includeRawValue === true) {
      _.forEach(def.props, (prop) =&gt; {
        prop['.rawValue'] = _.merge({}, prop).value
      })
    }
    // Globals
    this._resolveGlobals(def)
    // Validate
    this._validate(def)
    // Resolve any local aliases before resolving imports
    if (options.resolveAliases !== false) {
      this._resolveAliases(def, 'local')
    }
    // Collect all the import definitions
    let imports = this._resolveImports(def).map(i =&gt; i.def)
    // Merge the imported definitions
    def = _.merge.apply(null, _.flatten([{}, imports, def]))
    // Resolve any additional aliases that were depending on imports
    if (imports.length &gt; 0 &amp;&amp; options.resolveAliases !== false) {
      this._resolveAliases(def)
    }
    // Cleanup
    delete def.global
    delete def.imports
    // Save
    this.def = def
    return this
  }

  transform () {
    this._transformProps()
    return this
  }

  toBuffer () {
    return Buffer.from(this.toJSON(), 'utf8')
  }

  toJSON () {
    // Create a copy
    let def = _.merge({}, this.def)
    // Provide the keys for easy iteration
    def.propKeys = Object.keys(def.props)
    // Go
    return JSON.stringify(def, null, 2)
  }

  _resolveGlobals (def) {
    if (Object.keys(def.global).length === 0) return
    _.forEach(def.props, (prop, key) =&gt; {
      def.props[key] = Object.assign({}, def.global, prop)
    })
    delete def.global
  }

  _validate (def) {
    if (Array.isArray(def.props)) {
      throw TheoError('Design Token "props" key must be an object')
    }
    if (!_.has(def, 'props') || !_.isObject(def.props)) {
      def.props = {}
    }
    // Make sure properties have all required keys
    _.forEach(def.props, (prop, name) =&gt;
      ['value', 'type', 'category'].forEach(key =&gt; {
        if (!_.has(prop, key)) {
          throw TheoError(`prop "${name}" contained no "${key}" key`)
        }
      })
    )
  }

  _resolveAliases (def, type) {
    // convert all aliases to object format
    _.forEach(def.aliases, (value, key) =&gt; {
      if (typeof value !== 'object') {
        def.aliases[key] = { 'value': value }
      }
    })
    _.forEach(def.aliases, (replace, key) =&gt; {
      let s = _.escapeRegExp(key)
      _.forEach(def.aliases, alias =&gt;
        this._replaceAliasedValues(s, alias, replace, def, type))
      _.forEach(def.props, prop =&gt;
        this._replaceAliasedValues(s, prop, replace, def, type))
    })
  }

  _replaceAliasedValues (needle, haystack, replacement, def, type) {
    let isAlias = new RegExp(`{!${needle}}`, 'g')
    let isAliasStructure = RegExp('{![^}]*}', 'g')

    // Value contains an alias
    if (isAlias.test(haystack.value)) {
      // Resolve the alias
      haystack.value = haystack.value.replace(isAlias, replacement.value)
      // Pass original alias data to .alias key
      haystack['.alias'] = replacement
    }
    if ((type !== 'local') &amp;&amp; isAliasStructure.test(haystack.value)) {
      _.forEach(haystack.value.match(isAliasStructure), a =&gt; {
        let alias = a.toString().replace('{!', '').replace('}', '')
        if (!def.aliases[alias]) throw ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.registerFormat" id="apidoc.element.theo.registerFormat">
        function <span class="apidocSignatureSpan">theo.</span>registerFormat
        <span class="apidocSignatureSpan">(name, formatter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, formatter) =&gt; {
  if (typeof name !== 'string') {
    throw TheoError('format name must be a string')
  }
  if (typeof formatter !== 'function') {
    throw TheoError('format formatter must be a function')
  }
  FORMATS[name] = formatter
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }))
  .pipe(gulp.dest('dist'))
```

***

#### `theo.<span class="apidocCodeKeywordSpan">registerFormat</span>(name, formatter)`

Register a new format. Existing formats with the same name
will be overwritten.

**`@param {string} type`**
The name of the format
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.registerTransform" id="apidoc.element.theo.registerTransform">
        function <span class="apidocSignatureSpan">theo.</span>registerTransform
        <span class="apidocSignatureSpan">(name, valueTransforms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, valueTransforms) =&gt; {
  if (typeof name !== 'string') {
    throw TheoError('transform name must be a string')
  }
  if (!Array.isArray(valueTransforms)) {
    throw TheoError('valueTransforms must be an array of registered value transforms')
  }
  valueTransforms.forEach(t =&gt; {
    if (!_.has(VALUE_TRANSFORMS, t)) {
      throw TheoError('valueTransforms must be an array of registered value transforms')
    }
  })
  TRANSFORMS[name] = valueTransforms
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return json
    }
  }))
```

***

#### `theo.<span class="apidocCodeKeywordSpan">registerTransform</span>(type, valueTransforms)`

Register a new transform. Existing transforms with the same name
will be overwritten.

**`@param {string} type`**
The name of the transform
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.registerValueTransform" id="apidoc.element.theo.registerValueTransform">
        function <span class="apidocSignatureSpan">theo.</span>registerValueTransform
        <span class="apidocSignatureSpan">(name, matcher, transformer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, matcher, transformer) =&gt; {
  if (typeof name !== 'string') {
    throw TheoError('valueTransform name must be a string')
  }
  if (typeof matcher !== 'function') {
    throw TheoError('valueTransform matcher must be a function')
  }
  if (typeof transformer !== 'function') {
    throw TheoError('valueTransform transformer must be a function')
  }
  VALUE_TRANSFORMS[name] = {
    matcher: matcher,
    transformer: transformer
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`['color/hex8argb', 'relative/pixelValue', 'percentage/float']`

**aura**:
`['color/hex']`

***

#### `theo.<span class="apidocCodeKeywordSpan">registerValueTransform</span>(name, matcher, transformer)` &lt;a name="registerValueTransform
"&gt;&lt;/a&gt;

Register a new valueTransform. Existing valueTransforms with the same name
will be overwritten.

**`@param {string} type`**
The name of the valueTransform
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.transformIsRegistered" id="apidoc.element.theo.transformIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>transformIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&gt; typeof TRANSFORMS[name] !== 'undefined'</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.valueTransformIsRegistered" id="apidoc.element.theo.valueTransformIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>valueTransformIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&gt; typeof VALUE_TRANSFORMS[name] !== 'undefined'</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.formatIsRegistered" id="apidoc.module.theo.formatIsRegistered">module theo.formatIsRegistered</a></h1>


    <h2>
        <a href="#apidoc.element.theo.formatIsRegistered.formatIsRegistered" id="apidoc.element.theo.formatIsRegistered.formatIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>formatIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&gt; typeof FORMATS[name] !== 'undefined'</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.getFormat" id="apidoc.module.theo.getFormat">module theo.getFormat</a></h1>


    <h2>
        <a href="#apidoc.element.theo.getFormat.getFormat" id="apidoc.element.theo.getFormat.getFormat">
        function <span class="apidocSignatureSpan">theo.</span>getFormat
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFormat = function (name) {
  if (!this.formatIsRegistered(name)) {
    throw TheoError(`"${name}" is not a registered format`)
  }
  return FORMATS[name]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.getTransform" id="apidoc.module.theo.getTransform">module theo.getTransform</a></h1>


    <h2>
        <a href="#apidoc.element.theo.getTransform.getTransform" id="apidoc.element.theo.getTransform.getTransform">
        function <span class="apidocSignatureSpan">theo.</span>getTransform
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTransform = function (name) {
  if (!this.transformIsRegistered(name)) {
    throw TheoError(`"${name}" is not a registered transform`)
  }
  return _.merge([], TRANSFORMS[name])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.getValueTransform" id="apidoc.module.theo.getValueTransform">module theo.getValueTransform</a></h1>


    <h2>
        <a href="#apidoc.element.theo.getValueTransform.getValueTransform" id="apidoc.element.theo.getValueTransform.getValueTransform">
        function <span class="apidocSignatureSpan">theo.</span>getValueTransform
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValueTransform = function (name) {
  if (!this.valueTransformIsRegistered(name)) {
    throw TheoError(`"${name}" is not a registered valueTransform`)
  }
  return _.merge({}, VALUE_TRANSFORMS[name])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.kebabCase" id="apidoc.module.theo.kebabCase">module theo.kebabCase</a></h1>


    <h2>
        <a href="#apidoc.element.theo.kebabCase.kebabCase" id="apidoc.element.theo.kebabCase.kebabCase">
        function <span class="apidocSignatureSpan">theo.</span>kebabCase
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(string) =&gt; noCase(string, null, '-')</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.plugins" id="apidoc.module.theo.plugins">module theo.plugins</a></h1>


    <h2>
        <a href="#apidoc.element.theo.plugins.file" id="apidoc.element.theo.plugins.file">
        function <span class="apidocSignatureSpan">theo.plugins.</span>file
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(filePath) =&gt; {
  let stream = new through.obj()
  fs.readFile(filePath, (err, buffer) =&gt; {
    if (err) return stream.emit('error', err)
    let file = new gutil.File({
      path: filePath,
      contents: buffer
    })
    stream.write(file)
    stream.end()
  })
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;resources&gt;
  &lt;color name="colorBrand" type="color"&gt;#ffbada55&lt;/color&gt;
&lt;/resources&gt;
```

## API

#### `theo.plugins.<span class="apidocCodeKeywordSpan">file</span>(filePath)` &lt;a name="plugins.file"&gt;&lt;/
a&gt;

Push a new file into a transform stream and return the stream.
This is an alternative to using gulp.

**`@param {string} filePath`**
The name of the registered transform
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.format" id="apidoc.element.theo.plugins.format">
        function <span class="apidocSignatureSpan">theo.plugins.</span>format
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&gt; {
  let defaults = {
    propsFilter: () =&gt; true,
    propsMap: prop =&gt; prop
  }
  if (typeof options !== 'object') {
    throw TheoError('format() options must be an object')
  }
  options = _.merge({}, defaults, options)
  if (typeof options.propsFilter !== 'function') {
    throw TheoError('format() options.propsFilter must be a function')
  }
  if (typeof options.propsMap !== 'function') {
    throw TheoError('format() options.propsMap must be a function')
  }
  // Get the formatter
  if (typeof FORMATS[type] === 'undefined') {
    throw TheoError(`"${type}" is not a registerd format`)
  }
  let formatter = FORMATS[type]
  return through.obj((file, enc, next) =&gt; {
    let newFile = file.clone()
    // Get the transformed JSON
    let json = util.parsePropsFile(newFile)
    // Rename the file
    newFile.path = newFile.path.replace(/(json|yml)$/, type)
    // Run filter/map the props
    let updatedProps = _(json.props)
      .filter(options.propsFilter)
      .map(options.propsMap)
      .value()
    // Convert the props to a key/value
    json.props = _.reduce(updatedProps, (props, prop) =&gt; {
      props[prop.name] = prop
      return props
    }, {})
    json.propKeys = Object.keys(json.props)
    // Format the json
    let formatted = formatter(json, _.merge({}, options, {
      path: file.path
    }))
    // Set the file contents to the result of the formatter
    newFile.contents = Buffer.from(formatted, 'utf8')
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
const gulp = require('gulp')
const theo = require('theo')

gulp.src('design/props.json')
  .pipe(theo.plugins.transform('web'))
  .pipe(theo.plugins.<span class="apidocCodeKeywordSpan">format</span>('scss'))
  .pipe(gulp.dest('dist'))
```

## Design Tokens &lt;a name="overview"&gt;&lt;/a&gt;

Theo consumes **Design Token** files which are a central location to store
design related information such as colors, fonts, widths, animations, etc. These raw
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.getResult" id="apidoc.element.theo.plugins.getResult">
        function <span class="apidocSignatureSpan">theo.plugins.</span>getResult
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(callback) =&gt;
through.obj((file, enc, next) =&gt; {
  if (typeof callback === 'function' &amp;&amp; file.isBuffer()) {
    let result = file.contents.toString()
    callback(result)
    return next(null, file)
  }
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...
###### Styleguide

See &lt;https://salesforce-ux.github.io/design-properties&gt;.


***

#### `theo.plugins.<span class="apidocCodeKeywordSpan">getResult</span>([callback])`

Get the result of a transform/format

**`@param {function} [callback]`**
The function to call for each result in the stream

#### Example:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.transform" id="apidoc.element.theo.plugins.transform">
        function <span class="apidocSignatureSpan">theo.plugins.</span>transform
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&gt; {
  if (typeof options !== 'undefined' &amp;&amp; typeof options !== 'object') {
    throw TheoError('transform() options must be an object')
  }
  if (!_.has(TRANSFORMS, type)) {
    throw TheoError(`"${type}" is not a registered transform`)
  }
  let transform = TRANSFORMS[type].map(name =&gt; VALUE_TRANSFORMS[name])
  return through.obj((file, enc, next) =&gt; {
    let newFile = file.clone()
    try {
      newFile.contents = new PropSet(newFile, transform, options).transform().toBuffer()
    } catch (err) {
      return next(err)
    }
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Example

```js
const gulp = require('gulp')
const theo = require('theo')

gulp.src('design/props.json')
  .pipe(theo.plugins.<span class="apidocCodeKeywordSpan">transform</span>('web'))
  .pipe(theo.plugins.format('scss'))
  .pipe(gulp.dest('dist'))
```

## Design Tokens &lt;a name="overview"&gt;&lt;/a&gt;

Theo consumes **Design Token** files which are a central location to store
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.plugins.file" id="apidoc.module.theo.plugins.file">module theo.plugins.file</a></h1>


    <h2>
        <a href="#apidoc.element.theo.plugins.file.file" id="apidoc.element.theo.plugins.file.file">
        function <span class="apidocSignatureSpan">theo.plugins.</span>file
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(filePath) =&gt; {
  let stream = new through.obj()
  fs.readFile(filePath, (err, buffer) =&gt; {
    if (err) return stream.emit('error', err)
    let file = new gutil.File({
      path: filePath,
      contents: buffer
    })
    stream.write(file)
    stream.end()
  })
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;resources&gt;
  &lt;color name="colorBrand" type="color"&gt;#ffbada55&lt;/color&gt;
&lt;/resources&gt;
```

## API

#### `theo.plugins.<span class="apidocCodeKeywordSpan">file</span>(filePath)` &lt;a name="plugins.file"&gt;&lt;/
a&gt;

Push a new file into a transform stream and return the stream.
This is an alternative to using gulp.

**`@param {string} filePath`**
The name of the registered transform
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.plugins.format" id="apidoc.module.theo.plugins.format">module theo.plugins.format</a></h1>


    <h2>
        <a href="#apidoc.element.theo.plugins.format.format" id="apidoc.element.theo.plugins.format.format">
        function <span class="apidocSignatureSpan">theo.plugins.</span>format
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&gt; {
  let defaults = {
    propsFilter: () =&gt; true,
    propsMap: prop =&gt; prop
  }
  if (typeof options !== 'object') {
    throw TheoError('format() options must be an object')
  }
  options = _.merge({}, defaults, options)
  if (typeof options.propsFilter !== 'function') {
    throw TheoError('format() options.propsFilter must be a function')
  }
  if (typeof options.propsMap !== 'function') {
    throw TheoError('format() options.propsMap must be a function')
  }
  // Get the formatter
  if (typeof FORMATS[type] === 'undefined') {
    throw TheoError(`"${type}" is not a registerd format`)
  }
  let formatter = FORMATS[type]
  return through.obj((file, enc, next) =&gt; {
    let newFile = file.clone()
    // Get the transformed JSON
    let json = util.parsePropsFile(newFile)
    // Rename the file
    newFile.path = newFile.path.replace(/(json|yml)$/, type)
    // Run filter/map the props
    let updatedProps = _(json.props)
      .filter(options.propsFilter)
      .map(options.propsMap)
      .value()
    // Convert the props to a key/value
    json.props = _.reduce(updatedProps, (props, prop) =&gt; {
      props[prop.name] = prop
      return props
    }, {})
    json.propKeys = Object.keys(json.props)
    // Format the json
    let formatted = formatter(json, _.merge({}, options, {
      path: file.path
    }))
    // Set the file contents to the result of the formatter
    newFile.contents = Buffer.from(formatted, 'utf8')
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
const gulp = require('gulp')
const theo = require('theo')

gulp.src('design/props.json')
  .pipe(theo.plugins.transform('web'))
  .pipe(theo.plugins.<span class="apidocCodeKeywordSpan">format</span>('scss'))
  .pipe(gulp.dest('dist'))
```

## Design Tokens &lt;a name="overview"&gt;&lt;/a&gt;

Theo consumes **Design Token** files which are a central location to store
design related information such as colors, fonts, widths, animations, etc. These raw
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.plugins.getResult" id="apidoc.module.theo.plugins.getResult">module theo.plugins.getResult</a></h1>


    <h2>
        <a href="#apidoc.element.theo.plugins.getResult.getResult" id="apidoc.element.theo.plugins.getResult.getResult">
        function <span class="apidocSignatureSpan">theo.plugins.</span>getResult
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(callback) =&gt;
through.obj((file, enc, next) =&gt; {
  if (typeof callback === 'function' &amp;&amp; file.isBuffer()) {
    let result = file.contents.toString()
    callback(result)
    return next(null, file)
  }
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...
###### Styleguide

See &lt;https://salesforce-ux.github.io/design-properties&gt;.


***

#### `theo.plugins.<span class="apidocCodeKeywordSpan">getResult</span>([callback])`

Get the result of a transform/format

**`@param {function} [callback]`**
The function to call for each result in the stream

#### Example:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.plugins.transform" id="apidoc.module.theo.plugins.transform">module theo.plugins.transform</a></h1>


    <h2>
        <a href="#apidoc.element.theo.plugins.transform.transform" id="apidoc.element.theo.plugins.transform.transform">
        function <span class="apidocSignatureSpan">theo.plugins.</span>transform
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&gt; {
  if (typeof options !== 'undefined' &amp;&amp; typeof options !== 'object') {
    throw TheoError('transform() options must be an object')
  }
  if (!_.has(TRANSFORMS, type)) {
    throw TheoError(`"${type}" is not a registered transform`)
  }
  let transform = TRANSFORMS[type].map(name =&gt; VALUE_TRANSFORMS[name])
  return through.obj((file, enc, next) =&gt; {
    let newFile = file.clone()
    try {
      newFile.contents = new PropSet(newFile, transform, options).transform().toBuffer()
    } catch (err) {
      return next(err)
    }
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Example

```js
const gulp = require('gulp')
const theo = require('theo')

gulp.src('design/props.json')
  .pipe(theo.plugins.<span class="apidocCodeKeywordSpan">transform</span>('web'))
  .pipe(theo.plugins.format('scss'))
  .pipe(gulp.dest('dist'))
```

## Design Tokens &lt;a name="overview"&gt;&lt;/a&gt;

Theo consumes **Design Token** files which are a central location to store
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.prop_set" id="apidoc.module.theo.prop_set">module theo.prop_set</a></h1>


    <h2>
        <a href="#apidoc.element.theo.prop_set.prop_set" id="apidoc.element.theo.prop_set.prop_set">
        function <span class="apidocSignatureSpan">theo.</span>prop_set
        <span class="apidocSignatureSpan">(file, valueTransforms, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PropSet {

  constructor (file, valueTransforms, options = {}) {
    if (typeof file.isBuffer !== 'function' || typeof file.isBuffer === 'undefined') {
      throw TheoError('transform() must use vinyl files')
    }

    let defaults = {
      includeRawValue: false,
      includeMeta: false,
      resolveAliases: true
    }

    this.file = file
    this.path = file.path
    this.valueTransforms = valueTransforms
    this.options = Object.assign({}, defaults, options)

    this._init()
  }

  _init () {
    let { options } = this
    // Create the definition
    let def = {
      global: {},
      aliases: {}
    }
    // Merge the JSON into the definition
    try {
      let json = util.parsePropsFile(this.file)
      if (options.jsonPreProcess) {
        json = options.jsonPreProcess(json)
      }
      def = _.merge(def, json)
    } catch (e) {
      throw TheoError(`transform() encountered an invalid Design Token file: ${this.file.path}`)
    }
    // Raw
    if (options.includeRawValue === true) {
      _.forEach(def.props, (prop) =&gt; {
        prop['.rawValue'] = _.merge({}, prop).value
      })
    }
    // Globals
    this._resolveGlobals(def)
    // Validate
    this._validate(def)
    // Resolve any local aliases before resolving imports
    if (options.resolveAliases !== false) {
      this._resolveAliases(def, 'local')
    }
    // Collect all the import definitions
    let imports = this._resolveImports(def).map(i =&gt; i.def)
    // Merge the imported definitions
    def = _.merge.apply(null, _.flatten([{}, imports, def]))
    // Resolve any additional aliases that were depending on imports
    if (imports.length &gt; 0 &amp;&amp; options.resolveAliases !== false) {
      this._resolveAliases(def)
    }
    // Cleanup
    delete def.global
    delete def.imports
    // Save
    this.def = def
    return this
  }

  transform () {
    this._transformProps()
    return this
  }

  toBuffer () {
    return Buffer.from(this.toJSON(), 'utf8')
  }

  toJSON () {
    // Create a copy
    let def = _.merge({}, this.def)
    // Provide the keys for easy iteration
    def.propKeys = Object.keys(def.props)
    // Go
    return JSON.stringify(def, null, 2)
  }

  _resolveGlobals (def) {
    if (Object.keys(def.global).length === 0) return
    _.forEach(def.props, (prop, key) =&gt; {
      def.props[key] = Object.assign({}, def.global, prop)
    })
    delete def.global
  }

  _validate (def) {
    if (Array.isArray(def.props)) {
      throw TheoError('Design Token "props" key must be an object')
    }
    if (!_.has(def, 'props') || !_.isObject(def.props)) {
      def.props = {}
    }
    // Make sure properties have all required keys
    _.forEach(def.props, (prop, name) =&gt;
      ['value', 'type', 'category'].forEach(key =&gt; {
        if (!_.has(prop, key)) {
          throw TheoError(`prop "${name}" contained no "${key}" key`)
        }
      })
    )
  }

  _resolveAliases (def, type) {
    // convert all aliases to object format
    _.forEach(def.aliases, (value, key) =&gt; {
      if (typeof value !== 'object') {
        def.aliases[key] = { 'value': value }
      }
    })
    _.forEach(def.aliases, (replace, key) =&gt; {
      let s = _.escapeRegExp(key)
      _.forEach(def.aliases, alias =&gt;
        this._replaceAliasedValues(s, alias, replace, def, type))
      _.forEach(def.props, prop =&gt;
        this._replaceAliasedValues(s, prop, replace, def, type))
    })
  }

  _replaceAliasedValues (needle, haystack, replacement, def, type) {
    let isAlias = new RegExp(`{!${needle}}`, 'g')
    let isAliasStructure = RegExp('{![^}]*}', 'g')

    // Value contains an alias
    if (isAlias.test(haystack.value)) {
      // Resolve the alias
      haystack.value = haystack.value.replace(isAlias, replacement.value)
      // Pass original alias data to .alias key
      haystack['.alias'] = replacement
    }
    if ((type !== 'local') &amp;&amp; isAliasStructure.test(haystack.value)) {
      _.forEach(haystack.value.match(isAliasStructure), a =&gt; {
        let alias = a.toString().replace('{!', '').replace('}', '')
        if (!def.aliases[alias]) throw ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.registerFormat" id="apidoc.module.theo.registerFormat">module theo.registerFormat</a></h1>


    <h2>
        <a href="#apidoc.element.theo.registerFormat.registerFormat" id="apidoc.element.theo.registerFormat.registerFormat">
        function <span class="apidocSignatureSpan">theo.</span>registerFormat
        <span class="apidocSignatureSpan">(name, formatter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, formatter) =&gt; {
  if (typeof name !== 'string') {
    throw TheoError('format name must be a string')
  }
  if (typeof formatter !== 'function') {
    throw TheoError('format formatter must be a function')
  }
  FORMATS[name] = formatter
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }))
  .pipe(gulp.dest('dist'))
```

***

#### `theo.<span class="apidocCodeKeywordSpan">registerFormat</span>(name, formatter)`

Register a new format. Existing formats with the same name
will be overwritten.

**`@param {string} type`**
The name of the format
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.registerTransform" id="apidoc.module.theo.registerTransform">module theo.registerTransform</a></h1>


    <h2>
        <a href="#apidoc.element.theo.registerTransform.registerTransform" id="apidoc.element.theo.registerTransform.registerTransform">
        function <span class="apidocSignatureSpan">theo.</span>registerTransform
        <span class="apidocSignatureSpan">(name, valueTransforms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, valueTransforms) =&gt; {
  if (typeof name !== 'string') {
    throw TheoError('transform name must be a string')
  }
  if (!Array.isArray(valueTransforms)) {
    throw TheoError('valueTransforms must be an array of registered value transforms')
  }
  valueTransforms.forEach(t =&gt; {
    if (!_.has(VALUE_TRANSFORMS, t)) {
      throw TheoError('valueTransforms must be an array of registered value transforms')
    }
  })
  TRANSFORMS[name] = valueTransforms
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return json
    }
  }))
```

***

#### `theo.<span class="apidocCodeKeywordSpan">registerTransform</span>(type, valueTransforms)`

Register a new transform. Existing transforms with the same name
will be overwritten.

**`@param {string} type`**
The name of the transform
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.registerValueTransform" id="apidoc.module.theo.registerValueTransform">module theo.registerValueTransform</a></h1>


    <h2>
        <a href="#apidoc.element.theo.registerValueTransform.registerValueTransform" id="apidoc.element.theo.registerValueTransform.registerValueTransform">
        function <span class="apidocSignatureSpan">theo.</span>registerValueTransform
        <span class="apidocSignatureSpan">(name, matcher, transformer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, matcher, transformer) =&gt; {
  if (typeof name !== 'string') {
    throw TheoError('valueTransform name must be a string')
  }
  if (typeof matcher !== 'function') {
    throw TheoError('valueTransform matcher must be a function')
  }
  if (typeof transformer !== 'function') {
    throw TheoError('valueTransform transformer must be a function')
  }
  VALUE_TRANSFORMS[name] = {
    matcher: matcher,
    transformer: transformer
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`['color/hex8argb', 'relative/pixelValue', 'percentage/float']`

**aura**:
`['color/hex']`

***

#### `theo.<span class="apidocCodeKeywordSpan">registerValueTransform</span>(name, matcher, transformer)` &lt;a name="registerValueTransform
"&gt;&lt;/a&gt;

Register a new valueTransform. Existing valueTransforms with the same name
will be overwritten.

**`@param {string} type`**
The name of the valueTransform
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.transformIsRegistered" id="apidoc.module.theo.transformIsRegistered">module theo.transformIsRegistered</a></h1>


    <h2>
        <a href="#apidoc.element.theo.transformIsRegistered.transformIsRegistered" id="apidoc.element.theo.transformIsRegistered.transformIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>transformIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&gt; typeof TRANSFORMS[name] !== 'undefined'</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.valueTransformIsRegistered" id="apidoc.module.theo.valueTransformIsRegistered">module theo.valueTransformIsRegistered</a></h1>


    <h2>
        <a href="#apidoc.element.theo.valueTransformIsRegistered.valueTransformIsRegistered" id="apidoc.element.theo.valueTransformIsRegistered.valueTransformIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>valueTransformIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&gt; typeof VALUE_TRANSFORMS[name] !== 'undefined'</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>