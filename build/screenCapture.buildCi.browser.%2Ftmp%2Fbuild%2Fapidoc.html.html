<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/salesforce-ux/theo">theo (v5.0.0)</a>
</h1>
<h4>A set of Gulp plugins for transforming and formatting Design Tokens</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo">module theo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.formatIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>formatIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getFormat">
            function <span class="apidocSignatureSpan">theo.</span>getFormat
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getTransform">
            function <span class="apidocSignatureSpan">theo.</span>getTransform
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getValueTransform">
            function <span class="apidocSignatureSpan">theo.</span>getValueTransform
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.kebabCase">
            function <span class="apidocSignatureSpan">theo.</span>kebabCase
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerFormat">
            function <span class="apidocSignatureSpan">theo.</span>registerFormat
            <span class="apidocSignatureSpan">(name, formatter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerTransform">
            function <span class="apidocSignatureSpan">theo.</span>registerTransform
            <span class="apidocSignatureSpan">(name, valueTransforms)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerValueTransform">
            function <span class="apidocSignatureSpan">theo.</span>registerValueTransform
            <span class="apidocSignatureSpan">(name, matcher, transformer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.transformIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>transformIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.valueTransformIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>valueTransformIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">theo.</span>index</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">theo.</span>plugins</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.index">module theo.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.index.isRelativeSpacing">
            function <span class="apidocSignatureSpan">theo.index.</span>isRelativeSpacing
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.index.parsePropsFile">
            function <span class="apidocSignatureSpan">theo.index.</span>parsePropsFile
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.index.remToPx">
            function <span class="apidocSignatureSpan">theo.index.</span>remToPx
            <span class="apidocSignatureSpan">(rem, baseFontPercentage, baseFontPixel)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.plugins">module theo.plugins</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.file">
            function <span class="apidocSignatureSpan">theo.plugins.</span>file
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.format">
            function <span class="apidocSignatureSpan">theo.plugins.</span>format
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.getResult">
            function <span class="apidocSignatureSpan">theo.plugins.</span>getResult
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.transform">
            function <span class="apidocSignatureSpan">theo.plugins.</span>transform
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo" id="apidoc.module.theo">module theo</a></h1>


    <h2>
        <a href="#apidoc.element.theo.formatIsRegistered" id="apidoc.element.theo.formatIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>formatIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&gt; typeof FORMATS[name] !== 'undefined'</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Get a registered format
 *
 * @param {} name
 */
getFormat: function (name) {
  if (!this.<span class="apidocCodeKeywordSpan">formatIsRegistered</span>(name)) {
    throw TheoError(`"${name}" is not a registered format`)
  }
  return FORMATS[name]
},

/**
 * Transform a string to kebabCase
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.getFormat" id="apidoc.element.theo.getFormat">
        function <span class="apidocSignatureSpan">theo.</span>getFormat
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFormat = function (name) {
  if (!this.formatIsRegistered(name)) {
    throw TheoError(`"${name}" is not a registered format`)
  }
  return FORMATS[name]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.getTransform" id="apidoc.element.theo.getTransform">
        function <span class="apidocSignatureSpan">theo.</span>getTransform
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTransform = function (name) {
  if (!this.transformIsRegistered(name)) {
    throw TheoError(`"${name}" is not a registered transform`)
  }
  return _.merge([], TRANSFORMS[name])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.getValueTransform" id="apidoc.element.theo.getValueTransform">
        function <span class="apidocSignatureSpan">theo.</span>getValueTransform
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValueTransform = function (name) {
  if (!this.valueTransformIsRegistered(name)) {
    throw TheoError(`"${name}" is not a registered valueTransform`)
  }
  return _.merge({}, VALUE_TRANSFORMS[name])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.kebabCase" id="apidoc.element.theo.kebabCase">
        function <span class="apidocSignatureSpan">theo.</span>kebabCase
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(string) =&gt; noCase(string, null, '-')</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.registerFormat" id="apidoc.element.theo.registerFormat">
        function <span class="apidocSignatureSpan">theo.</span>registerFormat
        <span class="apidocSignatureSpan">(name, formatter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, formatter) =&gt; {
  if (typeof name !== 'string') {
    throw TheoError('format name must be a string')
  }
  if (typeof formatter !== 'function') {
    throw TheoError('format formatter must be a function')
  }
  FORMATS[name] = formatter
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }))
  .pipe(gulp.dest('dist'))
```

***

#### `theo.<span class="apidocCodeKeywordSpan">registerFormat</span>(name, formatter)`

Register a new format. Existing formats with the same name
will be overwritten.

**`@param {string} type`**
The name of the format
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.registerTransform" id="apidoc.element.theo.registerTransform">
        function <span class="apidocSignatureSpan">theo.</span>registerTransform
        <span class="apidocSignatureSpan">(name, valueTransforms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, valueTransforms) =&gt; {
  if (typeof name !== 'string') {
    throw TheoError('transform name must be a string')
  }
  if (!Array.isArray(valueTransforms)) {
    throw TheoError('valueTransforms must be an array of registered value transforms')
  }
  valueTransforms.forEach(t =&gt; {
    if (!_.has(VALUE_TRANSFORMS, t)) {
      throw TheoError('valueTransforms must be an array of registered value transforms')
    }
  })
  TRANSFORMS[name] = valueTransforms
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return json
    }
  }))
```

***

#### `theo.<span class="apidocCodeKeywordSpan">registerTransform</span>(type, valueTransforms)`

Register a new transform. Existing transforms with the same name
will be overwritten.

**`@param {string} type`**
The name of the transform
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.registerValueTransform" id="apidoc.element.theo.registerValueTransform">
        function <span class="apidocSignatureSpan">theo.</span>registerValueTransform
        <span class="apidocSignatureSpan">(name, matcher, transformer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, matcher, transformer) =&gt; {
  if (typeof name !== 'string') {
    throw TheoError('valueTransform name must be a string')
  }
  if (typeof matcher !== 'function') {
    throw TheoError('valueTransform matcher must be a function')
  }
  if (typeof transformer !== 'function') {
    throw TheoError('valueTransform transformer must be a function')
  }
  VALUE_TRANSFORMS[name] = {
    matcher: matcher,
    transformer: transformer
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`['color/hex8argb', 'relative/pixelValue', 'percentage/float']`

**aura**:
`['color/hex']`

***

#### `theo.<span class="apidocCodeKeywordSpan">registerValueTransform</span>(name, matcher, transformer)` &lt;a name="registerValueTransform
"&gt;&lt;/a&gt;

Register a new valueTransform. Existing valueTransforms with the same name
will be overwritten.

**`@param {string} type`**
The name of the valueTransform
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.transformIsRegistered" id="apidoc.element.theo.transformIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>transformIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&gt; typeof TRANSFORMS[name] !== 'undefined'</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Get a registered format
 *
 * @param {} name
 */
getTransform: function (name) {
  if (!this.<span class="apidocCodeKeywordSpan">transformIsRegistered</span>(name)) {
    throw TheoError(`"${name}" is not a registered transform`)
  }
  return _.merge([], TRANSFORMS[name])
},

/**
 * Register a new format. If a format with the provided
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.valueTransformIsRegistered" id="apidoc.element.theo.valueTransformIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>valueTransformIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&gt; typeof VALUE_TRANSFORMS[name] !== 'undefined'</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Get a registered valueTransform
 *
 * @param {} name
 */
getValueTransform: function (name) {
  if (!this.<span class="apidocCodeKeywordSpan">valueTransformIsRegistered</span>(name)) {
    throw TheoError(`"${name}" is not a registered valueTransform`)
  }
  return _.merge({}, VALUE_TRANSFORMS[name])
},

/**
 * Register a new transform. If a transform with the provided
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.index" id="apidoc.module.theo.index">module theo.index</a></h1>


    <h2>
        <a href="#apidoc.element.theo.index.isRelativeSpacing" id="apidoc.element.theo.index.isRelativeSpacing">
        function <span class="apidocSignatureSpan">theo.index.</span>isRelativeSpacing
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRelativeSpacing(value) {
  return /rem$/.test(value)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

registerValueTransform('percentage/float',
  prop =&gt; /%/.test(prop.value),
  prop =&gt; prop.value.replace(constants.PERCENTAGE_PATTERN, (match, number) =&gt; parseFloat(number / 100))
)

registerValueTransform('relative/pixel',
  prop =&gt; util.<span class="apidocCodeKeywordSpan">isRelativeSpacing</span>(prop.value),
  (prop, meta) =&gt; remToPx(prop, meta)
)

registerValueTransform('relative/pixelValue',
  prop =&gt; util.isRelativeSpacing(prop.value),
  (prop, meta) =&gt; remToPx(prop, meta).replace(/px$/g, '')
)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.index.parsePropsFile" id="apidoc.element.theo.index.parsePropsFile">
        function <span class="apidocSignatureSpan">theo.index.</span>parsePropsFile
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parsePropsFile(file) {
  switch (path.extname(file.path)) {
    case '.yaml':
    case '.yml':
      return yaml.safeLoad(file.contents.toString())
    default:
      return JSON5.parse(file.contents.toString())
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof FORMATS[type] === 'undefined') {
  throw TheoError(`"${type}" is not a registerd format`)
}
let formatter = FORMATS[type]
return through.obj((file, enc, next) =&gt; {
  let newFile = file.clone()
  // Get the transformed JSON
  let json = util.<span class="apidocCodeKeywordSpan">parsePropsFile</span>(newFile)
  // Rename the file
  newFile.path = newFile.path.replace(/(json|yml)$/, type)
  // Run filter/map the props
  let updatedProps = _(json.props)
    .filter(options.propsFilter)
    .map(options.propsMap)
    .value()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.index.remToPx" id="apidoc.element.theo.index.remToPx">
        function <span class="apidocSignatureSpan">theo.index.</span>remToPx
        <span class="apidocSignatureSpan">(rem, baseFontPercentage, baseFontPixel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remToPx(rem, baseFontPercentage, baseFontPixel) {
  return ((parseFloat(rem.replace(/rem/g, '')) * baseFontPixel) * (baseFontPercentage / 100)) + 'px'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    .replace(/^ {4}/gm, '')
    .replace(/^\s*\n/gm, '')
    .trim()

const remToPx = (prop, meta) =&gt; {
  const baseFontPercentage = typeof meta.baseFontPercentage === 'number' ? meta.baseFontPercentage : 100
  const baseFontPixel = typeof meta.baseFontPixel === 'number' ? meta.baseFontPixel : 16
  return util.<span class="apidocCodeKeywordSpan">remToPx</span>(prop.value, baseFontPercentage, baseFontPixel)
}

// //////////////////////////////////////////////////////////////////
// Value Transforms
// //////////////////////////////////////////////////////////////////

let VALUE_TRANSFORMS = {}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.plugins" id="apidoc.module.theo.plugins">module theo.plugins</a></h1>


    <h2>
        <a href="#apidoc.element.theo.plugins.file" id="apidoc.element.theo.plugins.file">
        function <span class="apidocSignatureSpan">theo.plugins.</span>file
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(filePath) =&gt; {
  let stream = new through.obj()
  fs.readFile(filePath, (err, buffer) =&gt; {
    if (err) return stream.emit('error', err)
    let file = new gutil.File({
      path: filePath,
      contents: buffer
    })
    stream.write(file)
    stream.end()
  })
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;resources&gt;
  &lt;color name="colorBrand" type="color"&gt;#ffbada55&lt;/color&gt;
&lt;/resources&gt;
```

## API

#### `theo.plugins.<span class="apidocCodeKeywordSpan">file</span>(filePath)` &lt;a name="plugins.file"&gt;&lt;/
a&gt;

Push a new file into a transform stream and return the stream.
This is an alternative to using gulp.

**`@param {string} filePath`**
The name of the registered transform
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.format" id="apidoc.element.theo.plugins.format">
        function <span class="apidocSignatureSpan">theo.plugins.</span>format
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&gt; {
  let defaults = {
    propsFilter: () =&gt; true,
    propsMap: prop =&gt; prop
  }
  if (typeof options !== 'object') {
    throw TheoError('format() options must be an object')
  }
  options = _.merge({}, defaults, options)
  if (typeof options.propsFilter !== 'function') {
    throw TheoError('format() options.propsFilter must be a function')
  }
  if (typeof options.propsMap !== 'function') {
    throw TheoError('format() options.propsMap must be a function')
  }
  // Get the formatter
  if (typeof FORMATS[type] === 'undefined') {
    throw TheoError(`"${type}" is not a registerd format`)
  }
  let formatter = FORMATS[type]
  return through.obj((file, enc, next) =&gt; {
    let newFile = file.clone()
    // Get the transformed JSON
    let json = util.parsePropsFile(newFile)
    // Rename the file
    newFile.path = newFile.path.replace(/(json|yml)$/, type)
    // Run filter/map the props
    let updatedProps = _(json.props)
      .filter(options.propsFilter)
      .map(options.propsMap)
      .value()
    // Convert the props to a key/value
    json.props = _.reduce(updatedProps, (props, prop) =&gt; {
      props[prop.name] = prop
      return props
    }, {})
    json.propKeys = Object.keys(json.props)
    // Format the json
    let formatted = formatter(json, _.merge({}, options, {
      path: file.path
    }))
    // Set the file contents to the result of the formatter
    newFile.contents = Buffer.from(formatted, 'utf8')
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
const gulp = require('gulp')
const theo = require('theo')

gulp.src('design/props.json')
  .pipe(theo.plugins.transform('web'))
  .pipe(theo.plugins.<span class="apidocCodeKeywordSpan">format</span>('scss'))
  .pipe(gulp.dest('dist'))
```

## Design Tokens &lt;a name="overview"&gt;&lt;/a&gt;

Theo consumes **Design Token** files which are a central location to store
design related information such as colors, fonts, widths, animations, etc. These raw
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.getResult" id="apidoc.element.theo.plugins.getResult">
        function <span class="apidocSignatureSpan">theo.plugins.</span>getResult
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(callback) =&gt;
through.obj((file, enc, next) =&gt; {
  if (typeof callback === 'function' &amp;&amp; file.isBuffer()) {
    let result = file.contents.toString()
    callback(result)
    return next(null, file)
  }
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...
###### Styleguide

See &lt;https://salesforce-ux.github.io/design-properties&gt;.


***

#### `theo.plugins.<span class="apidocCodeKeywordSpan">getResult</span>([callback])`

Get the result of a transform/format

**`@param {function} [callback]`**
The function to call for each result in the stream

#### Example:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.transform" id="apidoc.element.theo.plugins.transform">
        function <span class="apidocSignatureSpan">theo.plugins.</span>transform
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&gt; {
  if (typeof options !== 'undefined' &amp;&amp; typeof options !== 'object') {
    throw TheoError('transform() options must be an object')
  }
  if (!_.has(TRANSFORMS, type)) {
    throw TheoError(`"${type}" is not a registered transform`)
  }
  let transform = TRANSFORMS[type].map(name =&gt; VALUE_TRANSFORMS[name])
  return through.obj((file, enc, next) =&gt; {
    let newFile = file.clone()
    try {
      newFile.contents = new PropSet(newFile, transform, options).transform().toBuffer()
    } catch (err) {
      return next(err)
    }
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Example

```js
const gulp = require('gulp')
const theo = require('theo')

gulp.src('design/props.json')
  .pipe(theo.plugins.<span class="apidocCodeKeywordSpan">transform</span>('web'))
  .pipe(theo.plugins.format('scss'))
  .pipe(gulp.dest('dist'))
```

## Design Tokens &lt;a name="overview"&gt;&lt;/a&gt;

Theo consumes **Design Token** files which are a central location to store
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>