<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/salesforce-ux/theo"

    >theo (v5.0.0)</a>
</h1>
<h4>A set of Gulp plugins for transforming and formatting Design Tokens</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo">module theo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.formatIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>formatIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getFormat">
            function <span class="apidocSignatureSpan">theo.</span>getFormat
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getTransform">
            function <span class="apidocSignatureSpan">theo.</span>getTransform
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getValueTransform">
            function <span class="apidocSignatureSpan">theo.</span>getValueTransform
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.kebabCase">
            function <span class="apidocSignatureSpan">theo.</span>kebabCase
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerFormat">
            function <span class="apidocSignatureSpan">theo.</span>registerFormat
            <span class="apidocSignatureSpan">(name, formatter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerTransform">
            function <span class="apidocSignatureSpan">theo.</span>registerTransform
            <span class="apidocSignatureSpan">(name, valueTransforms)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerValueTransform">
            function <span class="apidocSignatureSpan">theo.</span>registerValueTransform
            <span class="apidocSignatureSpan">(name, matcher, transformer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.transformIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>transformIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.valueTransformIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>valueTransformIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">theo.</span>index</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">theo.</span>plugins</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.index">module theo.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.index.isRelativeSpacing">
            function <span class="apidocSignatureSpan">theo.index.</span>isRelativeSpacing
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.index.parsePropsFile">
            function <span class="apidocSignatureSpan">theo.index.</span>parsePropsFile
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.index.remToPx">
            function <span class="apidocSignatureSpan">theo.index.</span>remToPx
            <span class="apidocSignatureSpan">(rem, baseFontPercentage, baseFontPixel)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.plugins">module theo.plugins</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.file">
            function <span class="apidocSignatureSpan">theo.plugins.</span>file
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.format">
            function <span class="apidocSignatureSpan">theo.plugins.</span>format
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.getResult">
            function <span class="apidocSignatureSpan">theo.plugins.</span>getResult
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.transform">
            function <span class="apidocSignatureSpan">theo.plugins.</span>transform
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo" id="apidoc.module.theo">module theo</a></h1>


    <h2>
        <a href="#apidoc.element.theo.formatIsRegistered" id="apidoc.element.theo.formatIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>formatIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&#x3e; typeof FORMATS[name] !== &#x27;undefined&#x27;</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Get a registered format
 *
 * @param {} name
 */
getFormat: function (name) {
  if (!this.<span class="apidocCodeKeywordSpan">formatIsRegistered</span>(name)) {
    throw TheoError(`&#x22;${name}&#x22; is not a registered format`)
  }
  return FORMATS[name]
},

/**
 * Transform a string to kebabCase
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.getFormat" id="apidoc.element.theo.getFormat">
        function <span class="apidocSignatureSpan">theo.</span>getFormat
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFormat = function (name) {
  if (!this.formatIsRegistered(name)) {
    throw TheoError(`&#x22;${name}&#x22; is not a registered format`)
  }
  return FORMATS[name]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.getTransform" id="apidoc.element.theo.getTransform">
        function <span class="apidocSignatureSpan">theo.</span>getTransform
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTransform = function (name) {
  if (!this.transformIsRegistered(name)) {
    throw TheoError(`&#x22;${name}&#x22; is not a registered transform`)
  }
  return _.merge([], TRANSFORMS[name])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.getValueTransform" id="apidoc.element.theo.getValueTransform">
        function <span class="apidocSignatureSpan">theo.</span>getValueTransform
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValueTransform = function (name) {
  if (!this.valueTransformIsRegistered(name)) {
    throw TheoError(`&#x22;${name}&#x22; is not a registered valueTransform`)
  }
  return _.merge({}, VALUE_TRANSFORMS[name])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.kebabCase" id="apidoc.element.theo.kebabCase">
        function <span class="apidocSignatureSpan">theo.</span>kebabCase
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(string) =&#x3e; noCase(string, null, &#x27;-&#x27;)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.registerFormat" id="apidoc.element.theo.registerFormat">
        function <span class="apidocSignatureSpan">theo.</span>registerFormat
        <span class="apidocSignatureSpan">(name, formatter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, formatter) =&#x3e; {
  if (typeof name !== &#x27;string&#x27;) {
    throw TheoError(&#x27;format name must be a string&#x27;)
  }
  if (typeof formatter !== &#x27;function&#x27;) {
    throw TheoError(&#x27;format formatter must be a function&#x27;)
  }
  FORMATS[name] = formatter
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }))
  .pipe(gulp.dest(&#x27;dist&#x27;))
```

***

#### `theo.<span class="apidocCodeKeywordSpan">registerFormat</span>(name, formatter)`

Register a new format. Existing formats with the same name
will be overwritten.

**`@param {string} type`**
The name of the format
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.registerTransform" id="apidoc.element.theo.registerTransform">
        function <span class="apidocSignatureSpan">theo.</span>registerTransform
        <span class="apidocSignatureSpan">(name, valueTransforms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, valueTransforms) =&#x3e; {
  if (typeof name !== &#x27;string&#x27;) {
    throw TheoError(&#x27;transform name must be a string&#x27;)
  }
  if (!Array.isArray(valueTransforms)) {
    throw TheoError(&#x27;valueTransforms must be an array of registered value transforms&#x27;)
  }
  valueTransforms.forEach(t =&#x3e; {
    if (!_.has(VALUE_TRANSFORMS, t)) {
      throw TheoError(&#x27;valueTransforms must be an array of registered value transforms&#x27;)
    }
  })
  TRANSFORMS[name] = valueTransforms
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return json
    }
  }))
```

***

#### `theo.<span class="apidocCodeKeywordSpan">registerTransform</span>(type, valueTransforms)`

Register a new transform. Existing transforms with the same name
will be overwritten.

**`@param {string} type`**
The name of the transform
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.registerValueTransform" id="apidoc.element.theo.registerValueTransform">
        function <span class="apidocSignatureSpan">theo.</span>registerValueTransform
        <span class="apidocSignatureSpan">(name, matcher, transformer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, matcher, transformer) =&#x3e; {
  if (typeof name !== &#x27;string&#x27;) {
    throw TheoError(&#x27;valueTransform name must be a string&#x27;)
  }
  if (typeof matcher !== &#x27;function&#x27;) {
    throw TheoError(&#x27;valueTransform matcher must be a function&#x27;)
  }
  if (typeof transformer !== &#x27;function&#x27;) {
    throw TheoError(&#x27;valueTransform transformer must be a function&#x27;)
  }
  VALUE_TRANSFORMS[name] = {
    matcher: matcher,
    transformer: transformer
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`[&#x27;color/hex8argb&#x27;, &#x27;relative/pixelValue&#x27;, &#x27;percentage/float&#x27;]`

**aura**:
`[&#x27;color/hex&#x27;]`

***

#### `theo.<span class="apidocCodeKeywordSpan">registerValueTransform</span>(name, matcher, transformer)` &#x3c;a name=&#x22;registerValueTransform
&#x22;&#x3e;&#x3c;/a&#x3e;

Register a new valueTransform. Existing valueTransforms with the same name
will be overwritten.

**`@param {string} type`**
The name of the valueTransform
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.transformIsRegistered" id="apidoc.element.theo.transformIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>transformIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&#x3e; typeof TRANSFORMS[name] !== &#x27;undefined&#x27;</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Get a registered format
 *
 * @param {} name
 */
getTransform: function (name) {
  if (!this.<span class="apidocCodeKeywordSpan">transformIsRegistered</span>(name)) {
    throw TheoError(`&#x22;${name}&#x22; is not a registered transform`)
  }
  return _.merge([], TRANSFORMS[name])
},

/**
 * Register a new format. If a format with the provided
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.valueTransformIsRegistered" id="apidoc.element.theo.valueTransformIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>valueTransformIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&#x3e; typeof VALUE_TRANSFORMS[name] !== &#x27;undefined&#x27;</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Get a registered valueTransform
 *
 * @param {} name
 */
getValueTransform: function (name) {
  if (!this.<span class="apidocCodeKeywordSpan">valueTransformIsRegistered</span>(name)) {
    throw TheoError(`&#x22;${name}&#x22; is not a registered valueTransform`)
  }
  return _.merge({}, VALUE_TRANSFORMS[name])
},

/**
 * Register a new transform. If a transform with the provided
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.index" id="apidoc.module.theo.index">module theo.index</a></h1>


    <h2>
        <a href="#apidoc.element.theo.index.isRelativeSpacing" id="apidoc.element.theo.index.isRelativeSpacing">
        function <span class="apidocSignatureSpan">theo.index.</span>isRelativeSpacing
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRelativeSpacing(value) {
  return /rem$/.test(value)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

registerValueTransform(&#x27;percentage/float&#x27;,
  prop =&#x3e; /%/.test(prop.value),
  prop =&#x3e; prop.value.replace(constants.PERCENTAGE_PATTERN, (match, number) =&#x3e; parseFloat(number / 100))
)

registerValueTransform(&#x27;relative/pixel&#x27;,
  prop =&#x3e; util.<span class="apidocCodeKeywordSpan">isRelativeSpacing</span>(prop.value),
  (prop, meta) =&#x3e; remToPx(prop, meta)
)

registerValueTransform(&#x27;relative/pixelValue&#x27;,
  prop =&#x3e; util.isRelativeSpacing(prop.value),
  (prop, meta) =&#x3e; remToPx(prop, meta).replace(/px$/g, &#x27;&#x27;)
)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.index.parsePropsFile" id="apidoc.element.theo.index.parsePropsFile">
        function <span class="apidocSignatureSpan">theo.index.</span>parsePropsFile
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parsePropsFile(file) {
  switch (path.extname(file.path)) {
    case &#x27;.yaml&#x27;:
    case &#x27;.yml&#x27;:
      return yaml.safeLoad(file.contents.toString())
    default:
      return JSON5.parse(file.contents.toString())
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof FORMATS[type] === &#x27;undefined&#x27;) {
  throw TheoError(`&#x22;${type}&#x22; is not a registerd format`)
}
let formatter = FORMATS[type]
return through.obj((file, enc, next) =&#x3e; {
  let newFile = file.clone()
  // Get the transformed JSON
  let json = util.<span class="apidocCodeKeywordSpan">parsePropsFile</span>(newFile)
  // Rename the file
  newFile.path = newFile.path.replace(/(json|yml)$/, type)
  // Run filter/map the props
  let updatedProps = _(json.props)
    .filter(options.propsFilter)
    .map(options.propsMap)
    .value()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.index.remToPx" id="apidoc.element.theo.index.remToPx">
        function <span class="apidocSignatureSpan">theo.index.</span>remToPx
        <span class="apidocSignatureSpan">(rem, baseFontPercentage, baseFontPixel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remToPx(rem, baseFontPercentage, baseFontPixel) {
  return ((parseFloat(rem.replace(/rem/g, &#x27;&#x27;)) * baseFontPixel) * (baseFontPercentage / 100)) + &#x27;px&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    .replace(/^ {4}/gm, &#x27;&#x27;)
    .replace(/^\s*\n/gm, &#x27;&#x27;)
    .trim()

const remToPx = (prop, meta) =&#x3e; {
  const baseFontPercentage = typeof meta.baseFontPercentage === &#x27;number&#x27; ? meta.baseFontPercentage : 100
  const baseFontPixel = typeof meta.baseFontPixel === &#x27;number&#x27; ? meta.baseFontPixel : 16
  return util.<span class="apidocCodeKeywordSpan">remToPx</span>(prop.value, baseFontPercentage, baseFontPixel)
}

// //////////////////////////////////////////////////////////////////
// Value Transforms
// //////////////////////////////////////////////////////////////////

let VALUE_TRANSFORMS = {}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.plugins" id="apidoc.module.theo.plugins">module theo.plugins</a></h1>


    <h2>
        <a href="#apidoc.element.theo.plugins.file" id="apidoc.element.theo.plugins.file">
        function <span class="apidocSignatureSpan">theo.plugins.</span>file
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(filePath) =&#x3e; {
  let stream = new through.obj()
  fs.readFile(filePath, (err, buffer) =&#x3e; {
    if (err) return stream.emit(&#x27;error&#x27;, err)
    let file = new gutil.File({
      path: filePath,
      contents: buffer
    })
    stream.write(file)
    stream.end()
  })
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3c;resources&#x3e;
  &#x3c;color name=&#x22;colorBrand&#x22; type=&#x22;color&#x22;&#x3e;#ffbada55&#x3c;/color&#x3e;
&#x3c;/resources&#x3e;
```

## API

#### `theo.plugins.<span class="apidocCodeKeywordSpan">file</span>(filePath)` &#x3c;a name=&#x22;plugins.file&#x22;&#x3e;&#x3c;/
a&#x3e;

Push a new file into a transform stream and return the stream.
This is an alternative to using gulp.

**`@param {string} filePath`**
The name of the registered transform
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.format" id="apidoc.element.theo.plugins.format">
        function <span class="apidocSignatureSpan">theo.plugins.</span>format
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&#x3e; {
  let defaults = {
    propsFilter: () =&#x3e; true,
    propsMap: prop =&#x3e; prop
  }
  if (typeof options !== &#x27;object&#x27;) {
    throw TheoError(&#x27;format() options must be an object&#x27;)
  }
  options = _.merge({}, defaults, options)
  if (typeof options.propsFilter !== &#x27;function&#x27;) {
    throw TheoError(&#x27;format() options.propsFilter must be a function&#x27;)
  }
  if (typeof options.propsMap !== &#x27;function&#x27;) {
    throw TheoError(&#x27;format() options.propsMap must be a function&#x27;)
  }
  // Get the formatter
  if (typeof FORMATS[type] === &#x27;undefined&#x27;) {
    throw TheoError(`&#x22;${type}&#x22; is not a registerd format`)
  }
  let formatter = FORMATS[type]
  return through.obj((file, enc, next) =&#x3e; {
    let newFile = file.clone()
    // Get the transformed JSON
    let json = util.parsePropsFile(newFile)
    // Rename the file
    newFile.path = newFile.path.replace(/(json|yml)$/, type)
    // Run filter/map the props
    let updatedProps = _(json.props)
      .filter(options.propsFilter)
      .map(options.propsMap)
      .value()
    // Convert the props to a key/value
    json.props = _.reduce(updatedProps, (props, prop) =&#x3e; {
      props[prop.name] = prop
      return props
    }, {})
    json.propKeys = Object.keys(json.props)
    // Format the json
    let formatted = formatter(json, _.merge({}, options, {
      path: file.path
    }))
    // Set the file contents to the result of the formatter
    newFile.contents = Buffer.from(formatted, &#x27;utf8&#x27;)
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
const gulp = require(&#x27;gulp&#x27;)
const theo = require(&#x27;theo&#x27;)

gulp.src(&#x27;design/props.json&#x27;)
  .pipe(theo.plugins.transform(&#x27;web&#x27;))
  .pipe(theo.plugins.<span class="apidocCodeKeywordSpan">format</span>(&#x27;scss&#x27;))
  .pipe(gulp.dest(&#x27;dist&#x27;))
```

## Design Tokens &#x3c;a name=&#x22;overview&#x22;&#x3e;&#x3c;/a&#x3e;

Theo consumes **Design Token** files which are a central location to store
design related information such as colors, fonts, widths, animations, etc. These raw
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.getResult" id="apidoc.element.theo.plugins.getResult">
        function <span class="apidocSignatureSpan">theo.plugins.</span>getResult
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(callback) =&#x3e;
through.obj((file, enc, next) =&#x3e; {
  if (typeof callback === &#x27;function&#x27; &#x26;&#x26; file.isBuffer()) {
    let result = file.contents.toString()
    callback(result)
    return next(null, file)
  }
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...
###### Styleguide

See &#x3c;https://salesforce-ux.github.io/design-properties&#x3e;.


***

#### `theo.plugins.<span class="apidocCodeKeywordSpan">getResult</span>([callback])`

Get the result of a transform/format

**`@param {function} [callback]`**
The function to call for each result in the stream

#### Example:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.transform" id="apidoc.element.theo.plugins.transform">
        function <span class="apidocSignatureSpan">theo.plugins.</span>transform
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&#x3e; {
  if (typeof options !== &#x27;undefined&#x27; &#x26;&#x26; typeof options !== &#x27;object&#x27;) {
    throw TheoError(&#x27;transform() options must be an object&#x27;)
  }
  if (!_.has(TRANSFORMS, type)) {
    throw TheoError(`&#x22;${type}&#x22; is not a registered transform`)
  }
  let transform = TRANSFORMS[type].map(name =&#x3e; VALUE_TRANSFORMS[name])
  return through.obj((file, enc, next) =&#x3e; {
    let newFile = file.clone()
    try {
      newFile.contents = new PropSet(newFile, transform, options).transform().toBuffer()
    } catch (err) {
      return next(err)
    }
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Example

```js
const gulp = require(&#x27;gulp&#x27;)
const theo = require(&#x27;theo&#x27;)

gulp.src(&#x27;design/props.json&#x27;)
  .pipe(theo.plugins.<span class="apidocCodeKeywordSpan">transform</span>(&#x27;web&#x27;))
  .pipe(theo.plugins.format(&#x27;scss&#x27;))
  .pipe(gulp.dest(&#x27;dist&#x27;))
```

## Design Tokens &#x3c;a name=&#x22;overview&#x22;&#x3e;&#x3c;/a&#x3e;

Theo consumes **Design Token** files which are a central location to store
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
