<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/salesforce-ux/theo"

    >theo (v5.0.0)</a>
</h1>
<h4>A set of Gulp plugins for transforming and formatting Design Tokens</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo">module theo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.formatIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>formatIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getFormat">
            function <span class="apidocSignatureSpan">theo.</span>getFormat
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getTransform">
            function <span class="apidocSignatureSpan">theo.</span>getTransform
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getValueTransform">
            function <span class="apidocSignatureSpan">theo.</span>getValueTransform
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.kebabCase">
            function <span class="apidocSignatureSpan">theo.</span>kebabCase
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.file">
            function <span class="apidocSignatureSpan">theo.</span>plugins.file
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.format">
            function <span class="apidocSignatureSpan">theo.</span>plugins.format
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.getResult">
            function <span class="apidocSignatureSpan">theo.</span>plugins.getResult
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.transform">
            function <span class="apidocSignatureSpan">theo.</span>plugins.transform
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.prop_set">
            function <span class="apidocSignatureSpan">theo.</span>prop_set
            <span class="apidocSignatureSpan">(file, valueTransforms, options = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerFormat">
            function <span class="apidocSignatureSpan">theo.</span>registerFormat
            <span class="apidocSignatureSpan">(name, formatter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerTransform">
            function <span class="apidocSignatureSpan">theo.</span>registerTransform
            <span class="apidocSignatureSpan">(name, valueTransforms)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerValueTransform">
            function <span class="apidocSignatureSpan">theo.</span>registerValueTransform
            <span class="apidocSignatureSpan">(name, matcher, transformer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.transformIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>transformIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.valueTransformIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>valueTransformIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">theo.</span>plugins</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.formatIsRegistered">module theo.formatIsRegistered</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.formatIsRegistered.formatIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>formatIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.getFormat">module theo.getFormat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getFormat.getFormat">
            function <span class="apidocSignatureSpan">theo.</span>getFormat
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.getTransform">module theo.getTransform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getTransform.getTransform">
            function <span class="apidocSignatureSpan">theo.</span>getTransform
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.getValueTransform">module theo.getValueTransform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.getValueTransform.getValueTransform">
            function <span class="apidocSignatureSpan">theo.</span>getValueTransform
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.kebabCase">module theo.kebabCase</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.kebabCase.kebabCase">
            function <span class="apidocSignatureSpan">theo.</span>kebabCase
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.plugins">module theo.plugins</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.file">
            function <span class="apidocSignatureSpan">theo.plugins.</span>file
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.format">
            function <span class="apidocSignatureSpan">theo.plugins.</span>format
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.getResult">
            function <span class="apidocSignatureSpan">theo.plugins.</span>getResult
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.transform">
            function <span class="apidocSignatureSpan">theo.plugins.</span>transform
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.plugins.file">module theo.plugins.file</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.file.file">
            function <span class="apidocSignatureSpan">theo.plugins.</span>file
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.plugins.format">module theo.plugins.format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.format.format">
            function <span class="apidocSignatureSpan">theo.plugins.</span>format
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.plugins.getResult">module theo.plugins.getResult</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.getResult.getResult">
            function <span class="apidocSignatureSpan">theo.plugins.</span>getResult
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.plugins.transform">module theo.plugins.transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.plugins.transform.transform">
            function <span class="apidocSignatureSpan">theo.plugins.</span>transform
            <span class="apidocSignatureSpan">(type, options = {})</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.prop_set">module theo.prop_set</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.prop_set.prop_set">
            function <span class="apidocSignatureSpan">theo.</span>prop_set
            <span class="apidocSignatureSpan">(file, valueTransforms, options = {})</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.registerFormat">module theo.registerFormat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerFormat.registerFormat">
            function <span class="apidocSignatureSpan">theo.</span>registerFormat
            <span class="apidocSignatureSpan">(name, formatter)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.registerTransform">module theo.registerTransform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerTransform.registerTransform">
            function <span class="apidocSignatureSpan">theo.</span>registerTransform
            <span class="apidocSignatureSpan">(name, valueTransforms)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.registerValueTransform">module theo.registerValueTransform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.registerValueTransform.registerValueTransform">
            function <span class="apidocSignatureSpan">theo.</span>registerValueTransform
            <span class="apidocSignatureSpan">(name, matcher, transformer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.transformIsRegistered">module theo.transformIsRegistered</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.transformIsRegistered.transformIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>transformIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.theo.valueTransformIsRegistered">module theo.valueTransformIsRegistered</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.theo.valueTransformIsRegistered.valueTransformIsRegistered">
            function <span class="apidocSignatureSpan">theo.</span>valueTransformIsRegistered
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo" id="apidoc.module.theo">module theo</a></h1>


    <h2>
        <a href="#apidoc.element.theo.formatIsRegistered" id="apidoc.element.theo.formatIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>formatIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&#x3e; typeof FORMATS[name] !== &#x27;undefined&#x27;</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.getFormat" id="apidoc.element.theo.getFormat">
        function <span class="apidocSignatureSpan">theo.</span>getFormat
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFormat = function (name) {
  if (!this.formatIsRegistered(name)) {
    throw TheoError(`&#x22;${name}&#x22; is not a registered format`)
  }
  return FORMATS[name]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.getTransform" id="apidoc.element.theo.getTransform">
        function <span class="apidocSignatureSpan">theo.</span>getTransform
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTransform = function (name) {
  if (!this.transformIsRegistered(name)) {
    throw TheoError(`&#x22;${name}&#x22; is not a registered transform`)
  }
  return _.merge([], TRANSFORMS[name])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.getValueTransform" id="apidoc.element.theo.getValueTransform">
        function <span class="apidocSignatureSpan">theo.</span>getValueTransform
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValueTransform = function (name) {
  if (!this.valueTransformIsRegistered(name)) {
    throw TheoError(`&#x22;${name}&#x22; is not a registered valueTransform`)
  }
  return _.merge({}, VALUE_TRANSFORMS[name])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.kebabCase" id="apidoc.element.theo.kebabCase">
        function <span class="apidocSignatureSpan">theo.</span>kebabCase
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(string) =&#x3e; noCase(string, null, &#x27;-&#x27;)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.file" id="apidoc.element.theo.plugins.file">
        function <span class="apidocSignatureSpan">theo.</span>plugins.file
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(filePath) =&#x3e; {
  let stream = new through.obj()
  fs.readFile(filePath, (err, buffer) =&#x3e; {
    if (err) return stream.emit(&#x27;error&#x27;, err)
    let file = new gutil.File({
      path: filePath,
      contents: buffer
    })
    stream.write(file)
    stream.end()
  })
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3c;resources&#x3e;
  &#x3c;color name=&#x22;colorBrand&#x22; type=&#x22;color&#x22;&#x3e;#ffbada55&#x3c;/color&#x3e;
&#x3c;/resources&#x3e;
```

## API

#### `theo.<span class="apidocCodeKeywordSpan">plugins.file</span>(filePath)` &#x3c;a name=&#x22;plugins.file&#x22;&#x3e;&#x3c;/
a&#x3e;

Push a new file into a transform stream and return the stream.
This is an alternative to using gulp.

**`@param {string} filePath`**
The name of the registered transform
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.format" id="apidoc.element.theo.plugins.format">
        function <span class="apidocSignatureSpan">theo.</span>plugins.format
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&#x3e; {
  let defaults = {
    propsFilter: () =&#x3e; true,
    propsMap: prop =&#x3e; prop
  }
  if (typeof options !== &#x27;object&#x27;) {
    throw TheoError(&#x27;format() options must be an object&#x27;)
  }
  options = _.merge({}, defaults, options)
  if (typeof options.propsFilter !== &#x27;function&#x27;) {
    throw TheoError(&#x27;format() options.propsFilter must be a function&#x27;)
  }
  if (typeof options.propsMap !== &#x27;function&#x27;) {
    throw TheoError(&#x27;format() options.propsMap must be a function&#x27;)
  }
  // Get the formatter
  if (typeof FORMATS[type] === &#x27;undefined&#x27;) {
    throw TheoError(`&#x22;${type}&#x22; is not a registerd format`)
  }
  let formatter = FORMATS[type]
  return through.obj((file, enc, next) =&#x3e; {
    let newFile = file.clone()
    // Get the transformed JSON
    let json = util.parsePropsFile(newFile)
    // Rename the file
    newFile.path = newFile.path.replace(/(json|yml)$/, type)
    // Run filter/map the props
    let updatedProps = _(json.props)
      .filter(options.propsFilter)
      .map(options.propsMap)
      .value()
    // Convert the props to a key/value
    json.props = _.reduce(updatedProps, (props, prop) =&#x3e; {
      props[prop.name] = prop
      return props
    }, {})
    json.propKeys = Object.keys(json.props)
    // Format the json
    let formatted = formatter(json, _.merge({}, options, {
      path: file.path
    }))
    // Set the file contents to the result of the formatter
    newFile.contents = Buffer.from(formatted, &#x27;utf8&#x27;)
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
const gulp = require(&#x27;gulp&#x27;)
const theo = require(&#x27;theo&#x27;)

gulp.src(&#x27;design/props.json&#x27;)
  .pipe(theo.plugins.transform(&#x27;web&#x27;))
  .pipe(theo.<span class="apidocCodeKeywordSpan">plugins.format</span>(&#x27;scss&#x27;))
  .pipe(gulp.dest(&#x27;dist&#x27;))
```

## Design Tokens &#x3c;a name=&#x22;overview&#x22;&#x3e;&#x3c;/a&#x3e;

Theo consumes **Design Token** files which are a central location to store
design related information such as colors, fonts, widths, animations, etc. These raw
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.getResult" id="apidoc.element.theo.plugins.getResult">
        function <span class="apidocSignatureSpan">theo.</span>plugins.getResult
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(callback) =&#x3e;
through.obj((file, enc, next) =&#x3e; {
  if (typeof callback === &#x27;function&#x27; &#x26;&#x26; file.isBuffer()) {
    let result = file.contents.toString()
    callback(result)
    return next(null, file)
  }
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...
###### Styleguide

See &#x3c;https://salesforce-ux.github.io/design-properties&#x3e;.


***

#### `theo.<span class="apidocCodeKeywordSpan">plugins.getResult</span>([callback])`

Get the result of a transform/format

**`@param {function} [callback]`**
The function to call for each result in the stream

#### Example:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.transform" id="apidoc.element.theo.plugins.transform">
        function <span class="apidocSignatureSpan">theo.</span>plugins.transform
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&#x3e; {
  if (typeof options !== &#x27;undefined&#x27; &#x26;&#x26; typeof options !== &#x27;object&#x27;) {
    throw TheoError(&#x27;transform() options must be an object&#x27;)
  }
  if (!_.has(TRANSFORMS, type)) {
    throw TheoError(`&#x22;${type}&#x22; is not a registered transform`)
  }
  let transform = TRANSFORMS[type].map(name =&#x3e; VALUE_TRANSFORMS[name])
  return through.obj((file, enc, next) =&#x3e; {
    let newFile = file.clone()
    try {
      newFile.contents = new PropSet(newFile, transform, options).transform().toBuffer()
    } catch (err) {
      return next(err)
    }
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Example

```js
const gulp = require(&#x27;gulp&#x27;)
const theo = require(&#x27;theo&#x27;)

gulp.src(&#x27;design/props.json&#x27;)
  .pipe(theo.<span class="apidocCodeKeywordSpan">plugins.transform</span>(&#x27;web&#x27;))
  .pipe(theo.plugins.format(&#x27;scss&#x27;))
  .pipe(gulp.dest(&#x27;dist&#x27;))
```

## Design Tokens &#x3c;a name=&#x22;overview&#x22;&#x3e;&#x3c;/a&#x3e;

Theo consumes **Design Token** files which are a central location to store
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.prop_set" id="apidoc.element.theo.prop_set">
        function <span class="apidocSignatureSpan">theo.</span>prop_set
        <span class="apidocSignatureSpan">(file, valueTransforms, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PropSet {

  constructor (file, valueTransforms, options = {}) {
    if (typeof file.isBuffer !== &#x27;function&#x27; || typeof file.isBuffer === &#x27;undefined&#x27;) {
      throw TheoError(&#x27;transform() must use vinyl files&#x27;)
    }

    let defaults = {
      includeRawValue: false,
      includeMeta: false,
      resolveAliases: true
    }

    this.file = file
    this.path = file.path
    this.valueTransforms = valueTransforms
    this.options = Object.assign({}, defaults, options)

    this._init()
  }

  _init () {
    let { options } = this
    // Create the definition
    let def = {
      global: {},
      aliases: {}
    }
    // Merge the JSON into the definition
    try {
      let json = util.parsePropsFile(this.file)
      if (options.jsonPreProcess) {
        json = options.jsonPreProcess(json)
      }
      def = _.merge(def, json)
    } catch (e) {
      throw TheoError(`transform() encountered an invalid Design Token file: ${this.file.path}`)
    }
    // Raw
    if (options.includeRawValue === true) {
      _.forEach(def.props, (prop) =&#x3e; {
        prop[&#x27;.rawValue&#x27;] = _.merge({}, prop).value
      })
    }
    // Globals
    this._resolveGlobals(def)
    // Validate
    this._validate(def)
    // Resolve any local aliases before resolving imports
    if (options.resolveAliases !== false) {
      this._resolveAliases(def, &#x27;local&#x27;)
    }
    // Collect all the import definitions
    let imports = this._resolveImports(def).map(i =&#x3e; i.def)
    // Merge the imported definitions
    def = _.merge.apply(null, _.flatten([{}, imports, def]))
    // Resolve any additional aliases that were depending on imports
    if (imports.length &#x3e; 0 &#x26;&#x26; options.resolveAliases !== false) {
      this._resolveAliases(def)
    }
    // Cleanup
    delete def.global
    delete def.imports
    // Save
    this.def = def
    return this
  }

  transform () {
    this._transformProps()
    return this
  }

  toBuffer () {
    return Buffer.from(this.toJSON(), &#x27;utf8&#x27;)
  }

  toJSON () {
    // Create a copy
    let def = _.merge({}, this.def)
    // Provide the keys for easy iteration
    def.propKeys = Object.keys(def.props)
    // Go
    return JSON.stringify(def, null, 2)
  }

  _resolveGlobals (def) {
    if (Object.keys(def.global).length === 0) return
    _.forEach(def.props, (prop, key) =&#x3e; {
      def.props[key] = Object.assign({}, def.global, prop)
    })
    delete def.global
  }

  _validate (def) {
    if (Array.isArray(def.props)) {
      throw TheoError(&#x27;Design Token &#x22;props&#x22; key must be an object&#x27;)
    }
    if (!_.has(def, &#x27;props&#x27;) || !_.isObject(def.props)) {
      def.props = {}
    }
    // Make sure properties have all required keys
    _.forEach(def.props, (prop, name) =&#x3e;
      [&#x27;value&#x27;, &#x27;type&#x27;, &#x27;category&#x27;].forEach(key =&#x3e; {
        if (!_.has(prop, key)) {
          throw TheoError(`prop &#x22;${name}&#x22; contained no &#x22;${key}&#x22; key`)
        }
      })
    )
  }

  _resolveAliases (def, type) {
    // convert all aliases to object format
    _.forEach(def.aliases, (value, key) =&#x3e; {
      if (typeof value !== &#x27;object&#x27;) {
        def.aliases[key] = { &#x27;value&#x27;: value }
      }
    })
    _.forEach(def.aliases, (replace, key) =&#x3e; {
      let s = _.escapeRegExp(key)
      _.forEach(def.aliases, alias =&#x3e;
        this._replaceAliasedValues(s, alias, replace, def, type))
      _.forEach(def.props, prop =&#x3e;
        this._replaceAliasedValues(s, prop, replace, def, type))
    })
  }

  _replaceAliasedValues (needle, haystack, replacement, def, type) {
    let isAlias = new RegExp(`{!${needle}}`, &#x27;g&#x27;)
    let isAliasStructure = RegExp(&#x27;{![^}]*}&#x27;, &#x27;g&#x27;)

    // Value contains an alias
    if (isAlias.test(haystack.value)) {
      // Resolve the alias
      haystack.value = haystack.value.replace(isAlias, replacement.value)
      // Pass original alias data to .alias key
      haystack[&#x27;.alias&#x27;] = replacement
    }
    if ((type !== &#x27;local&#x27;) &#x26;&#x26; isAliasStructure.test(haystack.value)) {
      _.forEach(haystack.value.match(isAliasStructure), a =&#x3e; {
        let alias = a.toString().replace(&#x27;{!&#x27;, &#x27;&#x27;).replace(&#x27;}&#x27;, &#x27;&#x27;)
        if (!def.aliases[alias]) throw ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.registerFormat" id="apidoc.element.theo.registerFormat">
        function <span class="apidocSignatureSpan">theo.</span>registerFormat
        <span class="apidocSignatureSpan">(name, formatter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, formatter) =&#x3e; {
  if (typeof name !== &#x27;string&#x27;) {
    throw TheoError(&#x27;format name must be a string&#x27;)
  }
  if (typeof formatter !== &#x27;function&#x27;) {
    throw TheoError(&#x27;format formatter must be a function&#x27;)
  }
  FORMATS[name] = formatter
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }))
  .pipe(gulp.dest(&#x27;dist&#x27;))
```

***

#### `theo.<span class="apidocCodeKeywordSpan">registerFormat</span>(name, formatter)`

Register a new format. Existing formats with the same name
will be overwritten.

**`@param {string} type`**
The name of the format
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.registerTransform" id="apidoc.element.theo.registerTransform">
        function <span class="apidocSignatureSpan">theo.</span>registerTransform
        <span class="apidocSignatureSpan">(name, valueTransforms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, valueTransforms) =&#x3e; {
  if (typeof name !== &#x27;string&#x27;) {
    throw TheoError(&#x27;transform name must be a string&#x27;)
  }
  if (!Array.isArray(valueTransforms)) {
    throw TheoError(&#x27;valueTransforms must be an array of registered value transforms&#x27;)
  }
  valueTransforms.forEach(t =&#x3e; {
    if (!_.has(VALUE_TRANSFORMS, t)) {
      throw TheoError(&#x27;valueTransforms must be an array of registered value transforms&#x27;)
    }
  })
  TRANSFORMS[name] = valueTransforms
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return json
    }
  }))
```

***

#### `theo.<span class="apidocCodeKeywordSpan">registerTransform</span>(type, valueTransforms)`

Register a new transform. Existing transforms with the same name
will be overwritten.

**`@param {string} type`**
The name of the transform
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.registerValueTransform" id="apidoc.element.theo.registerValueTransform">
        function <span class="apidocSignatureSpan">theo.</span>registerValueTransform
        <span class="apidocSignatureSpan">(name, matcher, transformer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, matcher, transformer) =&#x3e; {
  if (typeof name !== &#x27;string&#x27;) {
    throw TheoError(&#x27;valueTransform name must be a string&#x27;)
  }
  if (typeof matcher !== &#x27;function&#x27;) {
    throw TheoError(&#x27;valueTransform matcher must be a function&#x27;)
  }
  if (typeof transformer !== &#x27;function&#x27;) {
    throw TheoError(&#x27;valueTransform transformer must be a function&#x27;)
  }
  VALUE_TRANSFORMS[name] = {
    matcher: matcher,
    transformer: transformer
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`[&#x27;color/hex8argb&#x27;, &#x27;relative/pixelValue&#x27;, &#x27;percentage/float&#x27;]`

**aura**:
`[&#x27;color/hex&#x27;]`

***

#### `theo.<span class="apidocCodeKeywordSpan">registerValueTransform</span>(name, matcher, transformer)` &#x3c;a name=&#x22;registerValueTransform
&#x22;&#x3e;&#x3c;/a&#x3e;

Register a new valueTransform. Existing valueTransforms with the same name
will be overwritten.

**`@param {string} type`**
The name of the valueTransform
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.transformIsRegistered" id="apidoc.element.theo.transformIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>transformIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&#x3e; typeof TRANSFORMS[name] !== &#x27;undefined&#x27;</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.valueTransformIsRegistered" id="apidoc.element.theo.valueTransformIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>valueTransformIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&#x3e; typeof VALUE_TRANSFORMS[name] !== &#x27;undefined&#x27;</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.formatIsRegistered" id="apidoc.module.theo.formatIsRegistered">module theo.formatIsRegistered</a></h1>


    <h2>
        <a href="#apidoc.element.theo.formatIsRegistered.formatIsRegistered" id="apidoc.element.theo.formatIsRegistered.formatIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>formatIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&#x3e; typeof FORMATS[name] !== &#x27;undefined&#x27;</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.getFormat" id="apidoc.module.theo.getFormat">module theo.getFormat</a></h1>


    <h2>
        <a href="#apidoc.element.theo.getFormat.getFormat" id="apidoc.element.theo.getFormat.getFormat">
        function <span class="apidocSignatureSpan">theo.</span>getFormat
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFormat = function (name) {
  if (!this.formatIsRegistered(name)) {
    throw TheoError(`&#x22;${name}&#x22; is not a registered format`)
  }
  return FORMATS[name]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.getTransform" id="apidoc.module.theo.getTransform">module theo.getTransform</a></h1>


    <h2>
        <a href="#apidoc.element.theo.getTransform.getTransform" id="apidoc.element.theo.getTransform.getTransform">
        function <span class="apidocSignatureSpan">theo.</span>getTransform
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTransform = function (name) {
  if (!this.transformIsRegistered(name)) {
    throw TheoError(`&#x22;${name}&#x22; is not a registered transform`)
  }
  return _.merge([], TRANSFORMS[name])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.getValueTransform" id="apidoc.module.theo.getValueTransform">module theo.getValueTransform</a></h1>


    <h2>
        <a href="#apidoc.element.theo.getValueTransform.getValueTransform" id="apidoc.element.theo.getValueTransform.getValueTransform">
        function <span class="apidocSignatureSpan">theo.</span>getValueTransform
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValueTransform = function (name) {
  if (!this.valueTransformIsRegistered(name)) {
    throw TheoError(`&#x22;${name}&#x22; is not a registered valueTransform`)
  }
  return _.merge({}, VALUE_TRANSFORMS[name])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.kebabCase" id="apidoc.module.theo.kebabCase">module theo.kebabCase</a></h1>


    <h2>
        <a href="#apidoc.element.theo.kebabCase.kebabCase" id="apidoc.element.theo.kebabCase.kebabCase">
        function <span class="apidocSignatureSpan">theo.</span>kebabCase
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(string) =&#x3e; noCase(string, null, &#x27;-&#x27;)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.plugins" id="apidoc.module.theo.plugins">module theo.plugins</a></h1>


    <h2>
        <a href="#apidoc.element.theo.plugins.file" id="apidoc.element.theo.plugins.file">
        function <span class="apidocSignatureSpan">theo.plugins.</span>file
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(filePath) =&#x3e; {
  let stream = new through.obj()
  fs.readFile(filePath, (err, buffer) =&#x3e; {
    if (err) return stream.emit(&#x27;error&#x27;, err)
    let file = new gutil.File({
      path: filePath,
      contents: buffer
    })
    stream.write(file)
    stream.end()
  })
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3c;resources&#x3e;
  &#x3c;color name=&#x22;colorBrand&#x22; type=&#x22;color&#x22;&#x3e;#ffbada55&#x3c;/color&#x3e;
&#x3c;/resources&#x3e;
```

## API

#### `theo.plugins.<span class="apidocCodeKeywordSpan">file</span>(filePath)` &#x3c;a name=&#x22;plugins.file&#x22;&#x3e;&#x3c;/
a&#x3e;

Push a new file into a transform stream and return the stream.
This is an alternative to using gulp.

**`@param {string} filePath`**
The name of the registered transform
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.format" id="apidoc.element.theo.plugins.format">
        function <span class="apidocSignatureSpan">theo.plugins.</span>format
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&#x3e; {
  let defaults = {
    propsFilter: () =&#x3e; true,
    propsMap: prop =&#x3e; prop
  }
  if (typeof options !== &#x27;object&#x27;) {
    throw TheoError(&#x27;format() options must be an object&#x27;)
  }
  options = _.merge({}, defaults, options)
  if (typeof options.propsFilter !== &#x27;function&#x27;) {
    throw TheoError(&#x27;format() options.propsFilter must be a function&#x27;)
  }
  if (typeof options.propsMap !== &#x27;function&#x27;) {
    throw TheoError(&#x27;format() options.propsMap must be a function&#x27;)
  }
  // Get the formatter
  if (typeof FORMATS[type] === &#x27;undefined&#x27;) {
    throw TheoError(`&#x22;${type}&#x22; is not a registerd format`)
  }
  let formatter = FORMATS[type]
  return through.obj((file, enc, next) =&#x3e; {
    let newFile = file.clone()
    // Get the transformed JSON
    let json = util.parsePropsFile(newFile)
    // Rename the file
    newFile.path = newFile.path.replace(/(json|yml)$/, type)
    // Run filter/map the props
    let updatedProps = _(json.props)
      .filter(options.propsFilter)
      .map(options.propsMap)
      .value()
    // Convert the props to a key/value
    json.props = _.reduce(updatedProps, (props, prop) =&#x3e; {
      props[prop.name] = prop
      return props
    }, {})
    json.propKeys = Object.keys(json.props)
    // Format the json
    let formatted = formatter(json, _.merge({}, options, {
      path: file.path
    }))
    // Set the file contents to the result of the formatter
    newFile.contents = Buffer.from(formatted, &#x27;utf8&#x27;)
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
const gulp = require(&#x27;gulp&#x27;)
const theo = require(&#x27;theo&#x27;)

gulp.src(&#x27;design/props.json&#x27;)
  .pipe(theo.plugins.transform(&#x27;web&#x27;))
  .pipe(theo.plugins.<span class="apidocCodeKeywordSpan">format</span>(&#x27;scss&#x27;))
  .pipe(gulp.dest(&#x27;dist&#x27;))
```

## Design Tokens &#x3c;a name=&#x22;overview&#x22;&#x3e;&#x3c;/a&#x3e;

Theo consumes **Design Token** files which are a central location to store
design related information such as colors, fonts, widths, animations, etc. These raw
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.getResult" id="apidoc.element.theo.plugins.getResult">
        function <span class="apidocSignatureSpan">theo.plugins.</span>getResult
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(callback) =&#x3e;
through.obj((file, enc, next) =&#x3e; {
  if (typeof callback === &#x27;function&#x27; &#x26;&#x26; file.isBuffer()) {
    let result = file.contents.toString()
    callback(result)
    return next(null, file)
  }
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...
###### Styleguide

See &#x3c;https://salesforce-ux.github.io/design-properties&#x3e;.


***

#### `theo.plugins.<span class="apidocCodeKeywordSpan">getResult</span>([callback])`

Get the result of a transform/format

**`@param {function} [callback]`**
The function to call for each result in the stream

#### Example:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.theo.plugins.transform" id="apidoc.element.theo.plugins.transform">
        function <span class="apidocSignatureSpan">theo.plugins.</span>transform
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&#x3e; {
  if (typeof options !== &#x27;undefined&#x27; &#x26;&#x26; typeof options !== &#x27;object&#x27;) {
    throw TheoError(&#x27;transform() options must be an object&#x27;)
  }
  if (!_.has(TRANSFORMS, type)) {
    throw TheoError(`&#x22;${type}&#x22; is not a registered transform`)
  }
  let transform = TRANSFORMS[type].map(name =&#x3e; VALUE_TRANSFORMS[name])
  return through.obj((file, enc, next) =&#x3e; {
    let newFile = file.clone()
    try {
      newFile.contents = new PropSet(newFile, transform, options).transform().toBuffer()
    } catch (err) {
      return next(err)
    }
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Example

```js
const gulp = require(&#x27;gulp&#x27;)
const theo = require(&#x27;theo&#x27;)

gulp.src(&#x27;design/props.json&#x27;)
  .pipe(theo.plugins.<span class="apidocCodeKeywordSpan">transform</span>(&#x27;web&#x27;))
  .pipe(theo.plugins.format(&#x27;scss&#x27;))
  .pipe(gulp.dest(&#x27;dist&#x27;))
```

## Design Tokens &#x3c;a name=&#x22;overview&#x22;&#x3e;&#x3c;/a&#x3e;

Theo consumes **Design Token** files which are a central location to store
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.plugins.file" id="apidoc.module.theo.plugins.file">module theo.plugins.file</a></h1>


    <h2>
        <a href="#apidoc.element.theo.plugins.file.file" id="apidoc.element.theo.plugins.file.file">
        function <span class="apidocSignatureSpan">theo.plugins.</span>file
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(filePath) =&#x3e; {
  let stream = new through.obj()
  fs.readFile(filePath, (err, buffer) =&#x3e; {
    if (err) return stream.emit(&#x27;error&#x27;, err)
    let file = new gutil.File({
      path: filePath,
      contents: buffer
    })
    stream.write(file)
    stream.end()
  })
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3c;resources&#x3e;
  &#x3c;color name=&#x22;colorBrand&#x22; type=&#x22;color&#x22;&#x3e;#ffbada55&#x3c;/color&#x3e;
&#x3c;/resources&#x3e;
```

## API

#### `theo.plugins.<span class="apidocCodeKeywordSpan">file</span>(filePath)` &#x3c;a name=&#x22;plugins.file&#x22;&#x3e;&#x3c;/
a&#x3e;

Push a new file into a transform stream and return the stream.
This is an alternative to using gulp.

**`@param {string} filePath`**
The name of the registered transform
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.plugins.format" id="apidoc.module.theo.plugins.format">module theo.plugins.format</a></h1>


    <h2>
        <a href="#apidoc.element.theo.plugins.format.format" id="apidoc.element.theo.plugins.format.format">
        function <span class="apidocSignatureSpan">theo.plugins.</span>format
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&#x3e; {
  let defaults = {
    propsFilter: () =&#x3e; true,
    propsMap: prop =&#x3e; prop
  }
  if (typeof options !== &#x27;object&#x27;) {
    throw TheoError(&#x27;format() options must be an object&#x27;)
  }
  options = _.merge({}, defaults, options)
  if (typeof options.propsFilter !== &#x27;function&#x27;) {
    throw TheoError(&#x27;format() options.propsFilter must be a function&#x27;)
  }
  if (typeof options.propsMap !== &#x27;function&#x27;) {
    throw TheoError(&#x27;format() options.propsMap must be a function&#x27;)
  }
  // Get the formatter
  if (typeof FORMATS[type] === &#x27;undefined&#x27;) {
    throw TheoError(`&#x22;${type}&#x22; is not a registerd format`)
  }
  let formatter = FORMATS[type]
  return through.obj((file, enc, next) =&#x3e; {
    let newFile = file.clone()
    // Get the transformed JSON
    let json = util.parsePropsFile(newFile)
    // Rename the file
    newFile.path = newFile.path.replace(/(json|yml)$/, type)
    // Run filter/map the props
    let updatedProps = _(json.props)
      .filter(options.propsFilter)
      .map(options.propsMap)
      .value()
    // Convert the props to a key/value
    json.props = _.reduce(updatedProps, (props, prop) =&#x3e; {
      props[prop.name] = prop
      return props
    }, {})
    json.propKeys = Object.keys(json.props)
    // Format the json
    let formatted = formatter(json, _.merge({}, options, {
      path: file.path
    }))
    // Set the file contents to the result of the formatter
    newFile.contents = Buffer.from(formatted, &#x27;utf8&#x27;)
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
const gulp = require(&#x27;gulp&#x27;)
const theo = require(&#x27;theo&#x27;)

gulp.src(&#x27;design/props.json&#x27;)
  .pipe(theo.plugins.transform(&#x27;web&#x27;))
  .pipe(theo.plugins.<span class="apidocCodeKeywordSpan">format</span>(&#x27;scss&#x27;))
  .pipe(gulp.dest(&#x27;dist&#x27;))
```

## Design Tokens &#x3c;a name=&#x22;overview&#x22;&#x3e;&#x3c;/a&#x3e;

Theo consumes **Design Token** files which are a central location to store
design related information such as colors, fonts, widths, animations, etc. These raw
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.plugins.getResult" id="apidoc.module.theo.plugins.getResult">module theo.plugins.getResult</a></h1>


    <h2>
        <a href="#apidoc.element.theo.plugins.getResult.getResult" id="apidoc.element.theo.plugins.getResult.getResult">
        function <span class="apidocSignatureSpan">theo.plugins.</span>getResult
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(callback) =&#x3e;
through.obj((file, enc, next) =&#x3e; {
  if (typeof callback === &#x27;function&#x27; &#x26;&#x26; file.isBuffer()) {
    let result = file.contents.toString()
    callback(result)
    return next(null, file)
  }
})</pre></li>
    <li>example usage<pre class="apidocCodePre">...
###### Styleguide

See &#x3c;https://salesforce-ux.github.io/design-properties&#x3e;.


***

#### `theo.plugins.<span class="apidocCodeKeywordSpan">getResult</span>([callback])`

Get the result of a transform/format

**`@param {function} [callback]`**
The function to call for each result in the stream

#### Example:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.plugins.transform" id="apidoc.module.theo.plugins.transform">module theo.plugins.transform</a></h1>


    <h2>
        <a href="#apidoc.element.theo.plugins.transform.transform" id="apidoc.element.theo.plugins.transform.transform">
        function <span class="apidocSignatureSpan">theo.plugins.</span>transform
        <span class="apidocSignatureSpan">(type, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(type, options = {}) =&#x3e; {
  if (typeof options !== &#x27;undefined&#x27; &#x26;&#x26; typeof options !== &#x27;object&#x27;) {
    throw TheoError(&#x27;transform() options must be an object&#x27;)
  }
  if (!_.has(TRANSFORMS, type)) {
    throw TheoError(`&#x22;${type}&#x22; is not a registered transform`)
  }
  let transform = TRANSFORMS[type].map(name =&#x3e; VALUE_TRANSFORMS[name])
  return through.obj((file, enc, next) =&#x3e; {
    let newFile = file.clone()
    try {
      newFile.contents = new PropSet(newFile, transform, options).transform().toBuffer()
    } catch (err) {
      return next(err)
    }
    next(null, newFile)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Example

```js
const gulp = require(&#x27;gulp&#x27;)
const theo = require(&#x27;theo&#x27;)

gulp.src(&#x27;design/props.json&#x27;)
  .pipe(theo.plugins.<span class="apidocCodeKeywordSpan">transform</span>(&#x27;web&#x27;))
  .pipe(theo.plugins.format(&#x27;scss&#x27;))
  .pipe(gulp.dest(&#x27;dist&#x27;))
```

## Design Tokens &#x3c;a name=&#x22;overview&#x22;&#x3e;&#x3c;/a&#x3e;

Theo consumes **Design Token** files which are a central location to store
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.prop_set" id="apidoc.module.theo.prop_set">module theo.prop_set</a></h1>


    <h2>
        <a href="#apidoc.element.theo.prop_set.prop_set" id="apidoc.element.theo.prop_set.prop_set">
        function <span class="apidocSignatureSpan">theo.</span>prop_set
        <span class="apidocSignatureSpan">(file, valueTransforms, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PropSet {

  constructor (file, valueTransforms, options = {}) {
    if (typeof file.isBuffer !== &#x27;function&#x27; || typeof file.isBuffer === &#x27;undefined&#x27;) {
      throw TheoError(&#x27;transform() must use vinyl files&#x27;)
    }

    let defaults = {
      includeRawValue: false,
      includeMeta: false,
      resolveAliases: true
    }

    this.file = file
    this.path = file.path
    this.valueTransforms = valueTransforms
    this.options = Object.assign({}, defaults, options)

    this._init()
  }

  _init () {
    let { options } = this
    // Create the definition
    let def = {
      global: {},
      aliases: {}
    }
    // Merge the JSON into the definition
    try {
      let json = util.parsePropsFile(this.file)
      if (options.jsonPreProcess) {
        json = options.jsonPreProcess(json)
      }
      def = _.merge(def, json)
    } catch (e) {
      throw TheoError(`transform() encountered an invalid Design Token file: ${this.file.path}`)
    }
    // Raw
    if (options.includeRawValue === true) {
      _.forEach(def.props, (prop) =&#x3e; {
        prop[&#x27;.rawValue&#x27;] = _.merge({}, prop).value
      })
    }
    // Globals
    this._resolveGlobals(def)
    // Validate
    this._validate(def)
    // Resolve any local aliases before resolving imports
    if (options.resolveAliases !== false) {
      this._resolveAliases(def, &#x27;local&#x27;)
    }
    // Collect all the import definitions
    let imports = this._resolveImports(def).map(i =&#x3e; i.def)
    // Merge the imported definitions
    def = _.merge.apply(null, _.flatten([{}, imports, def]))
    // Resolve any additional aliases that were depending on imports
    if (imports.length &#x3e; 0 &#x26;&#x26; options.resolveAliases !== false) {
      this._resolveAliases(def)
    }
    // Cleanup
    delete def.global
    delete def.imports
    // Save
    this.def = def
    return this
  }

  transform () {
    this._transformProps()
    return this
  }

  toBuffer () {
    return Buffer.from(this.toJSON(), &#x27;utf8&#x27;)
  }

  toJSON () {
    // Create a copy
    let def = _.merge({}, this.def)
    // Provide the keys for easy iteration
    def.propKeys = Object.keys(def.props)
    // Go
    return JSON.stringify(def, null, 2)
  }

  _resolveGlobals (def) {
    if (Object.keys(def.global).length === 0) return
    _.forEach(def.props, (prop, key) =&#x3e; {
      def.props[key] = Object.assign({}, def.global, prop)
    })
    delete def.global
  }

  _validate (def) {
    if (Array.isArray(def.props)) {
      throw TheoError(&#x27;Design Token &#x22;props&#x22; key must be an object&#x27;)
    }
    if (!_.has(def, &#x27;props&#x27;) || !_.isObject(def.props)) {
      def.props = {}
    }
    // Make sure properties have all required keys
    _.forEach(def.props, (prop, name) =&#x3e;
      [&#x27;value&#x27;, &#x27;type&#x27;, &#x27;category&#x27;].forEach(key =&#x3e; {
        if (!_.has(prop, key)) {
          throw TheoError(`prop &#x22;${name}&#x22; contained no &#x22;${key}&#x22; key`)
        }
      })
    )
  }

  _resolveAliases (def, type) {
    // convert all aliases to object format
    _.forEach(def.aliases, (value, key) =&#x3e; {
      if (typeof value !== &#x27;object&#x27;) {
        def.aliases[key] = { &#x27;value&#x27;: value }
      }
    })
    _.forEach(def.aliases, (replace, key) =&#x3e; {
      let s = _.escapeRegExp(key)
      _.forEach(def.aliases, alias =&#x3e;
        this._replaceAliasedValues(s, alias, replace, def, type))
      _.forEach(def.props, prop =&#x3e;
        this._replaceAliasedValues(s, prop, replace, def, type))
    })
  }

  _replaceAliasedValues (needle, haystack, replacement, def, type) {
    let isAlias = new RegExp(`{!${needle}}`, &#x27;g&#x27;)
    let isAliasStructure = RegExp(&#x27;{![^}]*}&#x27;, &#x27;g&#x27;)

    // Value contains an alias
    if (isAlias.test(haystack.value)) {
      // Resolve the alias
      haystack.value = haystack.value.replace(isAlias, replacement.value)
      // Pass original alias data to .alias key
      haystack[&#x27;.alias&#x27;] = replacement
    }
    if ((type !== &#x27;local&#x27;) &#x26;&#x26; isAliasStructure.test(haystack.value)) {
      _.forEach(haystack.value.match(isAliasStructure), a =&#x3e; {
        let alias = a.toString().replace(&#x27;{!&#x27;, &#x27;&#x27;).replace(&#x27;}&#x27;, &#x27;&#x27;)
        if (!def.aliases[alias]) throw ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.registerFormat" id="apidoc.module.theo.registerFormat">module theo.registerFormat</a></h1>


    <h2>
        <a href="#apidoc.element.theo.registerFormat.registerFormat" id="apidoc.element.theo.registerFormat.registerFormat">
        function <span class="apidocSignatureSpan">theo.</span>registerFormat
        <span class="apidocSignatureSpan">(name, formatter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, formatter) =&#x3e; {
  if (typeof name !== &#x27;string&#x27;) {
    throw TheoError(&#x27;format name must be a string&#x27;)
  }
  if (typeof formatter !== &#x27;function&#x27;) {
    throw TheoError(&#x27;format formatter must be a function&#x27;)
  }
  FORMATS[name] = formatter
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }))
  .pipe(gulp.dest(&#x27;dist&#x27;))
```

***

#### `theo.<span class="apidocCodeKeywordSpan">registerFormat</span>(name, formatter)`

Register a new format. Existing formats with the same name
will be overwritten.

**`@param {string} type`**
The name of the format
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.registerTransform" id="apidoc.module.theo.registerTransform">module theo.registerTransform</a></h1>


    <h2>
        <a href="#apidoc.element.theo.registerTransform.registerTransform" id="apidoc.element.theo.registerTransform.registerTransform">
        function <span class="apidocSignatureSpan">theo.</span>registerTransform
        <span class="apidocSignatureSpan">(name, valueTransforms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, valueTransforms) =&#x3e; {
  if (typeof name !== &#x27;string&#x27;) {
    throw TheoError(&#x27;transform name must be a string&#x27;)
  }
  if (!Array.isArray(valueTransforms)) {
    throw TheoError(&#x27;valueTransforms must be an array of registered value transforms&#x27;)
  }
  valueTransforms.forEach(t =&#x3e; {
    if (!_.has(VALUE_TRANSFORMS, t)) {
      throw TheoError(&#x27;valueTransforms must be an array of registered value transforms&#x27;)
    }
  })
  TRANSFORMS[name] = valueTransforms
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return json
    }
  }))
```

***

#### `theo.<span class="apidocCodeKeywordSpan">registerTransform</span>(type, valueTransforms)`

Register a new transform. Existing transforms with the same name
will be overwritten.

**`@param {string} type`**
The name of the transform
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.registerValueTransform" id="apidoc.module.theo.registerValueTransform">module theo.registerValueTransform</a></h1>


    <h2>
        <a href="#apidoc.element.theo.registerValueTransform.registerValueTransform" id="apidoc.element.theo.registerValueTransform.registerValueTransform">
        function <span class="apidocSignatureSpan">theo.</span>registerValueTransform
        <span class="apidocSignatureSpan">(name, matcher, transformer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name, matcher, transformer) =&#x3e; {
  if (typeof name !== &#x27;string&#x27;) {
    throw TheoError(&#x27;valueTransform name must be a string&#x27;)
  }
  if (typeof matcher !== &#x27;function&#x27;) {
    throw TheoError(&#x27;valueTransform matcher must be a function&#x27;)
  }
  if (typeof transformer !== &#x27;function&#x27;) {
    throw TheoError(&#x27;valueTransform transformer must be a function&#x27;)
  }
  VALUE_TRANSFORMS[name] = {
    matcher: matcher,
    transformer: transformer
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`[&#x27;color/hex8argb&#x27;, &#x27;relative/pixelValue&#x27;, &#x27;percentage/float&#x27;]`

**aura**:
`[&#x27;color/hex&#x27;]`

***

#### `theo.<span class="apidocCodeKeywordSpan">registerValueTransform</span>(name, matcher, transformer)` &#x3c;a name=&#x22;registerValueTransform
&#x22;&#x3e;&#x3c;/a&#x3e;

Register a new valueTransform. Existing valueTransforms with the same name
will be overwritten.

**`@param {string} type`**
The name of the valueTransform
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.transformIsRegistered" id="apidoc.module.theo.transformIsRegistered">module theo.transformIsRegistered</a></h1>


    <h2>
        <a href="#apidoc.element.theo.transformIsRegistered.transformIsRegistered" id="apidoc.element.theo.transformIsRegistered.transformIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>transformIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&#x3e; typeof TRANSFORMS[name] !== &#x27;undefined&#x27;</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.theo.valueTransformIsRegistered" id="apidoc.module.theo.valueTransformIsRegistered">module theo.valueTransformIsRegistered</a></h1>


    <h2>
        <a href="#apidoc.element.theo.valueTransformIsRegistered.valueTransformIsRegistered" id="apidoc.element.theo.valueTransformIsRegistered.valueTransformIsRegistered">
        function <span class="apidocSignatureSpan">theo.</span>valueTransformIsRegistered
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(name) =&#x3e; typeof VALUE_TRANSFORMS[name] !== &#x27;undefined&#x27;</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
